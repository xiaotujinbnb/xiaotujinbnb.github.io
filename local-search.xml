<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>strace实现原理：ptrace系统调用</title>
    <link href="/2022/11/14/strace%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9Aptrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2022/11/14/strace%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9Aptrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是strace？"><a href="#什么是strace？" class="headerlink" title="什么是strace？"></a>什么是strace？</h1><p>根据strace官网的描述，strace是一个Linux用户空间跟踪器，可用于诊断、调试和教学。我们用它来监控用户空间进程和内核之间的交互，比如系统调用、信令、进程状态变化等等。</p><p>strace 使用内核的 ptrace 特性来实现其功能。</p><p>在运维的日常工作中，故障处理和问题诊断是主要内容和必备技能。strace 可以作为跟踪故障过程的有效工具。就像侦探通过系统调用的痕迹告诉你异常的真相。</p><p>这次想分享一个实用的东西，就是写一个strace工具。</p><p>用过strace的同学都知道，strace是用来跟踪进程调用的系统调用的，还可以统计进程调用对系统调用的统计。strace有两种使用方式，如下：</p><p>strace的过程<br>strace -p 进程 pid<br>第一个用于跟踪要执行的程序，而第二个用于跟踪正在运行的进程。</p><p>下图是用 strace 跟踪 ls 命令的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ strace <span class="hljs-built_in">ls</span><br>--- Process 15332 created<br>--- Process 15332 loaded C:\Windows\System32\ntdll.dll at 00007ffdd6fd0000<br>--- Process 15332 loaded C:\Windows\System32\kernel32.dll at 00007ffdd4660000<br>--- Process 15332 loaded C:\Windows\System32\KernelBase.dll at 00007ffdd40b0000<br>--- Process 15332 thread 2208 created<br>--- Process 15332 thread 9072 created<br>--- Process 15332 loaded D:\Program Files (x86)\cygwin64\bin\cygwin1.dll at 0000000180040000<br>--- Process 15332 loaded D:\Program Files (x86)\cygwin64\bin\cygintl-8.dll at 00000003c0ba0000<br>--- Process 15332 thread 13508 created<br>--- Process 15332 loaded D:\Program Files (x86)\cygwin64\bin\cygiconv-2.dll at 00000003cf8b0000<br>    0       0 [main] <span class="hljs-built_in">ls</span> (15332) **********************************************<br>   42      42 [main] <span class="hljs-built_in">ls</span> (15332) Program name: D:\Program Files (x86)\cygwin64\bin\ls.exe (windows pid 15332)<br>   27      69 [main] <span class="hljs-built_in">ls</span> (15332) OS version:   Windows NT-10.0<br>   24      93 [main] <span class="hljs-built_in">ls</span> (15332) **********************************************<br>--- Process 15332 loaded C:\Windows\System32\advapi32.dll at 00007ffdd4500000<br>--- Process 15332 loaded C:\Windows\System32\msvcrt.dll at 00007ffdd6830000<br>--- Process 15332 loaded C:\Windows\System32\sechost.dll at 00007ffdd4a50000<br>--- Process 15332 loaded C:\Windows\System32\rpcrt4.dll at 00007ffdd48d0000<br><br>A lot is omitted here<br><br>   19   24022 [main] <span class="hljs-built_in">ls</span> 588 proc_terminate: nprocs 0<br>   19   24041 [main] <span class="hljs-built_in">ls</span> 588 proc_terminate: leaving<br>   25   24066 [main] <span class="hljs-built_in">ls</span> 588 pinfo::<span class="hljs-built_in">exit</span>: Calling dlls.cleanup_forkables n 0x0, exitcode 0x0<br>   21   24087 [main] <span class="hljs-built_in">ls</span> 588 pinfo::<span class="hljs-built_in">exit</span>: Calling ExitProcess n 0x0, exitcode 0x0<br>--- Process 15332 (pid: 588) thread 9072 exited with status 0x0<br>--- Process 15332 (pid: 588) thread 2208 exited with status 0x0<br>--- Process 15332 (pid: 588) thread 6340 exited with status 0x0<br>--- Process 15332 (pid: 588) thread 13508 exited with status 0x0<br>--- Process 15332 (pid: 588) exited with status 0x0<br></code></pre></td></tr></table></figure><h1 id="自己写一个-strace-的第一步是了解-ptrace-系统调用的使用。我们来看看ptrace-系统调用的定义"><a href="#自己写一个-strace-的第一步是了解-ptrace-系统调用的使用。我们来看看ptrace-系统调用的定义" class="headerlink" title="自己写一个 strace 的第一步是了解 ptrace() 系统调用的使用。我们来看看ptrace()系统调用的定义"></a>自己写一个 strace 的第一步是了解 ptrace() 系统调用的使用。我们来看看ptrace()系统调用的定义</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">int ptrace(long request, long pid, long addr, long data);<br></code></pre></td></tr></table></figure><p>ptrace() 系统调用用于跟踪进程的运行状态。下面介绍其参数的含义：</p><p>请求：指定要跟踪的操作。换句话说，可以通过传入不同的请求参数，对进程进行不同的跟踪。可选值是：<br>PTRACE_TRACEME<br>PTRACE_PEEKTEXT<br>PTRACE_POKETEXT<br>PTRACE_CONT<br>PTRACE_SINGLESTEP<br>…<br>PID：指定要跟踪的进程的PID。<br>addr：指定要读取或修改的内存地址。<br>数据：对于不同的请求操作，数据有不同的作用，下面会分别介绍。<br>如前所述，有两种方法可以使用 strace 跟踪进程。一种是通过strace命令启动进程，另一种是通过-p指定要跟踪的进程。</p><p>ptrace() 系统调用还提供了两种“请求”来实现上述两种方式：</p><p>第一个是通过 ptrace_Trace</p><p>第二个是通过 PTRACE_ATTACH</p><p>本文主要介绍第一种方法。由于第一种方法使用跟踪器启动被跟踪程序，因此需要启动两个进程。通常，可以使用 fork() 系统调用来创建一个新进程，所以我们自然也使用了 fork() 系统调用。</p><p>我们新建一个文件strace.c，输入代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">int main(int argc, char *argv[])&#123;<br>    pid_t child;<br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        // Child process<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // Parent process<br>    &#125;<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码通过调用fork()创建了一个子进程，但是什么都不做。之后，我们将在子进程中运行被跟踪的程序，在父进程中运行跟踪进程代码。</p><h1 id="运行跟踪的程序"><a href="#运行跟踪的程序" class="headerlink" title="运行跟踪的程序"></a>运行跟踪的程序</h1><p>如前所述，被跟踪的程序需要在子进程中运行。要运行程序，您可以调用 execl() 系统。因此，您可以通过以下代码在子进程中运行 ls 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><br>int main(int argc, char *argv[])&#123;<br>    pid_t child;<br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // Parent process<br>    &#125;<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>execl() 用于执行指定的程序。如果执行成功，则不会返回。因此，EXECL(…) 的下一行代码 exit(0) 将不会被执行。</p><p>由于我们需要跟踪ls命令，所以在执行ls命令之前必须调用ptrace(ptrace_trace,0,null,null)来告诉系统需要跟踪进程。代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><br>int main(int argc, char *argv[])<br>&#123;<br>    pid_t child;<br><br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        ptrace(PTRACE_TRACEME, 0, NULL, NULL);<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // Parent process<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了被跟踪进程部分的代码，然后启动跟踪进程部分的代码。</p><h1 id="编写跟踪过程代码"><a href="#编写跟踪过程代码" class="headerlink" title="编写跟踪过程代码"></a>编写跟踪过程代码</h1><p>如果你编译运行上面的代码，你会发现没有任何效果。这是因为当子进程调用 ptrace (ptrace_trace, 0, null, null) 并调用 execl() 系统调用时，子进程会向父进程（跟踪进程）发送 SIGCHLD 信号并停止运行本身。直到父进程发送调试命令，它才会继续运行。</p><p>因为在上面的代码中，父进程（跟踪进程）并没有发送任何调试命令退出，所以子进程（被跟踪进程）没有运行就随父进程退出，所以你不会看到任何效果。</p><p>现在让我们开始编写代码来跟踪这个过程。</p><p>由于被跟踪进程会向跟踪进程发送 SIGCHLD 消息，所以我们必须首先在跟踪进程的代码中接收到 SIGCHLD 信号。接收信号通过“wait()”系统调用完成，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int main(int argc, char *argv[])<br>&#123;<br>    pid_t child;<br>    int status;<br><br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        ptrace(PTRACE_TRACEME, 0, NULL, NULL);<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码调用“wait()”系统调用接收被跟踪进程发送的SIGCHLD信号，接下来需要开始向被跟踪进程发送调试命令，对被跟踪进程进行调试。</p><p>由于本文介绍了如何跟踪某个进程进行了哪些系统调用，所以我们需要使用 ptrace() 的 ptrace_syscall 命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/user.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int main(int argc, char *argv[])<br>&#123;<br>    pid_t child;<br>    int status;<br>    struct user_regs_struct regs;<br>    int orig_rax;<br><br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        ptrace(PTRACE_TRACEME, 0, NULL, NULL);<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br><br>        // 1. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> is given to the tracked process (parameters of system call can be obtained before calling system call)<br>        ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br><br>        // 2. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> to the tracked process (after calling the system call, you can get the <span class="hljs-built_in">return</span> value of the system call)<br>        ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出，我们调用了两次ptrace(ptrace_syscall,child,null,null)。这是因为在跟踪系统调用时，需要跟踪系统调用前的环境（如获取系统调用的参数）和系统调用后的环境（如获取系统调用的返回值） . 因此，ptrace(ptrace)需要调用两次_SYSCALL,child,NULL,NULL)。</p><h1 id="获取进程寄存器的值"><a href="#获取进程寄存器的值" class="headerlink" title="获取进程寄存器的值"></a>获取进程寄存器的值</h1><p>Linux系统调用通过CPU寄存器传递参数，因此要获取调用哪个系统调用，必须获取进程寄存器的值。获取进程寄存器的值，可以通过ptrace() system_getregs命令调用，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/user.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int main(int argc, char *argv[])<br>&#123;<br>    pid_t child;<br>    int status;<br>    struct user_regs_struct regs;<br>    int orig_rax;<br><br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        ptrace(PTRACE_TRACEME, 0, NULL, NULL);<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br><br>        // 1. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> is given to the tracked process (parameters of system call can be obtained before calling system call)<br>        ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br><br>        ptrace(PTRACE_GETREGS, child, 0, &amp;regs); // Gets the value of the tracked process register<br><br>        orig_rax = regs.orig_rax; // Gets the value of the rax register<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;orig_rax: %d\n&quot;</span>, orig_rax); // Print the value of the rax register<br><br>        // 2. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> to the tracked process (after calling the system call, you can get the <span class="hljs-built_in">return</span> value of the system call)<br>        ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码调用ptrace(ptrace)<em>getregs,child,0,®s)获取进程寄存器的值，ptrace_getregs命令需要传入data参数中user的类型_regs_指向struct结构体的指针，user</em> regs_struct结构定义如下（在文件sys&#x2F;user.h中）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">struct user_regs_struct &#123;<br>    unsigned long r15,r14,r13,r12,rbp,rbx,r11,r10;<br>    unsigned long r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;<br>    unsigned long rip,cs,eflags;<br>    unsigned long rsp,ss;<br>    unsigned long fs_base, gs_base;<br>    unsigned long ds,es,fs,gs;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中struct结构体的user_regs_orig_rax保存了系统调用号，所以我们可以通过orig_rax的值来知道调用了哪个系统调用。</p><p>编译运行上述代码，会输出结果：orig_rax: 12，表示系统调用编号为12。那么系统调用编号12是多少呢？您可以通过以下链接查看：</p><p><a href="https://www.cnblogs.com/gavanwanggw/p/6920826.html">https://www.cnblogs.com/gavanwanggw/p/6920826.html</a></p><p>通过查找系统调用表，我们可以知道系统调用号12是brk()，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">System call number     Function name     entry point     Source code<br>...<br>12            brk       sys_brk    mm/mmap.c<br>...<br></code></pre></td></tr></table></figure><p>上面的程序只跟踪一个系统调用，那么如何跟踪所有的系统调用呢？很简单，就是把被跟踪的代码放到一个无限循环中。代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/user.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int main(int argc, char *argv[])<br>&#123;<br>    pid_t child;<br>    int status;<br>    struct user_regs_struct regs;<br>    int orig_rax;<br><br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        ptrace(PTRACE_TRACEME, 0, NULL, NULL);<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br><br>        <span class="hljs-keyword">while</span> (1) &#123;<br>            // 1. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> is given to the tracked process (parameters of system call can be obtained before calling system call)<br>            ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>            <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br>            <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123; // If the child process exits, the trace is terminated<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br><br>            ptrace(PTRACE_GETREGS, child, 0, &amp;regs); // Gets the value of the tracked process register<br><br>            orig_rax = regs.orig_rax; // Gets the value of the rax register<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;orig_rax: %d\n&quot;</span>, orig_rax); // Print the value of the rax register<br><br>            // 2. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> to the tracked process (after calling the system call, you can get the <span class="hljs-built_in">return</span> value of the system call)<br>            ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>            <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br>            <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123; // If the child process exits, the trace is terminated<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>这行代码用于判断子进程（被跟踪的进程）是否退出，如果退出，则停止跟踪。现在您可以编译并运行该程序。输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost liexusong]$ ./strace<br>orig_rax: 12<br>orig_rax: 9<br>orig_rax: 21<br>orig_rax: 2<br>orig_rax: 5<br>orig_rax: 9<br>orig_rax: 3<br>orig_rax: 2<br>orig_rax: 0<br>orig_rax: 5<br>orig_rax: 9<br>orig_rax: 10<br>orig_rax: 9<br>orig_rax: 9<br>orig_rax: 3<br>orig_rax: 2<br>orig_rax: 0<br>orig_rax: 5<br>orig_rax: 9<br>orig_rax: 10<br>...<br></code></pre></td></tr></table></figure><p>从执行结果来看，只是打印系统调用号不直观，那我们该如何优化呢？</p><p>我们可以定义一个系统调用号和系统调用名的对应表来实现更清晰的输出结果，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/user.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>struct syscall &#123;<br>    int  code;<br>    char *name;<br>&#125; syscall_table[] = &#123;<br>    &#123;0, <span class="hljs-string">&quot;read&quot;</span>&#125;,<br>    &#123;1, <span class="hljs-string">&quot;write&quot;</span>&#125;,<br>    &#123;2, <span class="hljs-string">&quot;open&quot;</span>&#125;,<br>    &#123;3, <span class="hljs-string">&quot;close&quot;</span>&#125;,<br>    &#123;4, <span class="hljs-string">&quot;stat&quot;</span>&#125;,<br>    &#123;5, <span class="hljs-string">&quot;fstat&quot;</span>&#125;,<br>    &#123;6, <span class="hljs-string">&quot;lstat&quot;</span>&#125;,<br>    &#123;7, <span class="hljs-string">&quot;poll&quot;</span>&#125;,<br>    &#123;8, <span class="hljs-string">&quot;lseek&quot;</span>&#125;,<br>    ...<br>    &#123;-1, NULL&#125;,<br>&#125;<br><br>char *find_syscall_symbol(int code) &#123;<br>    struct syscall *sc;<br><br>    <span class="hljs-keyword">for</span> (sc = syscall_table; sc-&gt;code &gt;= 0; sc++) &#123;<br>        <span class="hljs-keyword">if</span> (sc-&gt;code == code) &#123;<br>            <span class="hljs-built_in">return</span> sc-&gt;name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> NULL;<br>&#125;<br><br>int main(int argc, char *argv[])<br>&#123;<br>    pid_t child;<br>    int status;<br>    struct user_regs_struct regs;<br>    int orig_rax;<br><br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        ptrace(PTRACE_TRACEME, 0, NULL, NULL);<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br><br>        <span class="hljs-keyword">while</span> (1) &#123;<br>            // 1. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> is given to the tracked process (parameters of system call can be obtained before calling system call)<br>            ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>            <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br>            <span class="hljs-keyword">if</span>(WIFEXITED(status)) &#123; // If the child process exits, the trace is terminated<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br><br>            ptrace(PTRACE_GETREGS, child, 0, &amp;regs); // Gets the value of the tracked process register<br><br>            orig_rax = regs.orig_rax; // Gets the value of the rax register<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;syscall: %s()\n&quot;</span>, find_syscall_symbol(orig_rax)); // Print system call<br><br>            // 2. Send PTRACE_SYSCALL <span class="hljs-built_in">command</span> to the tracked process (after calling the system call, you can get the <span class="hljs-built_in">return</span> value of the system call)<br>            ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>            <span class="hljs-built_in">wait</span>(&amp;status); // Receive SIGCHLD signal sent by subprocess<br>            <span class="hljs-keyword">if</span>(WIFEXITED(status)) &#123; // If the child process is terminated, <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子增加了一个函数，find_syscall_symbol() 来获取系统调用号对应的系统调用名，实现比较简单。输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost liexusong]$ ./strace<br>syscall: brk()<br>syscall: mmap()<br>syscall: access()<br>syscall: open()<br>syscall: fstat()<br>syscall: mmap()<br>syscall: close()<br>syscall: open()<br>syscall: <span class="hljs-built_in">read</span>()<br>syscall: fstat()<br>syscall: mmap()<br>syscall: mprotect()<br>syscall: mmap()<br>syscall: mmap()<br>syscall: close()<br>...<br></code></pre></td></tr></table></figure><p>从执行结果来看，我们现在可以打印系统调用的名称，但是我们知道 strace 命令也会打印系统调用参数的值。我们可以使用 ptrace() 系统调用 PTRACE_PEEKTEXT 和 PTRACE_PEEKDATA 来获取参数的值，所以有兴趣自己实现这个效果。</p><p>本文完整代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/user.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>struct syscall &#123;<br>    int  code;<br>    char *name;<br>&#125; syscall_table[] = &#123;<br>    &#123;0, <span class="hljs-string">&quot;read&quot;</span>&#125;,<br>    &#123;1, <span class="hljs-string">&quot;write&quot;</span>&#125;,<br>    &#123;2, <span class="hljs-string">&quot;open&quot;</span>&#125;,<br>    &#123;3, <span class="hljs-string">&quot;close&quot;</span>&#125;,<br>    &#123;4, <span class="hljs-string">&quot;stat&quot;</span>&#125;,<br>    &#123;5, <span class="hljs-string">&quot;fstat&quot;</span>&#125;,<br>    &#123;6, <span class="hljs-string">&quot;lstat&quot;</span>&#125;,<br>    &#123;7, <span class="hljs-string">&quot;poll&quot;</span>&#125;,<br>    &#123;8, <span class="hljs-string">&quot;lseek&quot;</span>&#125;,<br>    &#123;9, <span class="hljs-string">&quot;mmap&quot;</span>&#125;,<br>    &#123;10, <span class="hljs-string">&quot;mprotect&quot;</span>&#125;,<br>    &#123;11, <span class="hljs-string">&quot;munmap&quot;</span>&#125;,<br>    &#123;12, <span class="hljs-string">&quot;brk&quot;</span>&#125;,<br>    &#123;13, <span class="hljs-string">&quot;rt_sigaction&quot;</span>&#125;,<br>    &#123;14, <span class="hljs-string">&quot;rt_sigprocmask&quot;</span>&#125;,<br>    &#123;15, <span class="hljs-string">&quot;rt_sigreturn&quot;</span>&#125;,<br>    &#123;16, <span class="hljs-string">&quot;ioctl&quot;</span>&#125;,<br>    &#123;17, <span class="hljs-string">&quot;pread64&quot;</span>&#125;,<br>    &#123;18, <span class="hljs-string">&quot;pwrite64&quot;</span>&#125;,<br>    &#123;19, <span class="hljs-string">&quot;readv&quot;</span>&#125;,<br>    &#123;20, <span class="hljs-string">&quot;writev&quot;</span>&#125;,<br>    &#123;21, <span class="hljs-string">&quot;access&quot;</span>&#125;,<br>    &#123;22, <span class="hljs-string">&quot;pipe&quot;</span>&#125;,<br>    &#123;23, <span class="hljs-string">&quot;select&quot;</span>&#125;,<br>    &#123;24, <span class="hljs-string">&quot;sched_yield&quot;</span>&#125;,<br>    &#123;25, <span class="hljs-string">&quot;mremap&quot;</span>&#125;,<br>    &#123;26, <span class="hljs-string">&quot;msync&quot;</span>&#125;,<br>    &#123;27, <span class="hljs-string">&quot;mincore&quot;</span>&#125;,<br>    &#123;28, <span class="hljs-string">&quot;madvise&quot;</span>&#125;,<br>    &#123;29, <span class="hljs-string">&quot;shmget&quot;</span>&#125;,<br>    &#123;30, <span class="hljs-string">&quot;shmat&quot;</span>&#125;,<br>    &#123;31, <span class="hljs-string">&quot;shmctl&quot;</span>&#125;,<br>    &#123;32, <span class="hljs-string">&quot;dup&quot;</span>&#125;,<br>    &#123;33, <span class="hljs-string">&quot;dup2&quot;</span>&#125;,<br>    &#123;34, <span class="hljs-string">&quot;pause&quot;</span>&#125;,<br>    &#123;35, <span class="hljs-string">&quot;nanosleep&quot;</span>&#125;,<br>    &#123;36, <span class="hljs-string">&quot;getitimer&quot;</span>&#125;,<br>    &#123;37, <span class="hljs-string">&quot;alarm&quot;</span>&#125;,<br>    &#123;38, <span class="hljs-string">&quot;setitimer&quot;</span>&#125;,<br>    &#123;39, <span class="hljs-string">&quot;getpid&quot;</span>&#125;,<br>    &#123;40, <span class="hljs-string">&quot;sendfile&quot;</span>&#125;,<br>    &#123;41, <span class="hljs-string">&quot;socket&quot;</span>&#125;,<br>    &#123;42, <span class="hljs-string">&quot;connect&quot;</span>&#125;,<br>    &#123;43, <span class="hljs-string">&quot;accept&quot;</span>&#125;,<br>    &#123;44, <span class="hljs-string">&quot;sendto&quot;</span>&#125;,<br>    &#123;45, <span class="hljs-string">&quot;recvfrom&quot;</span>&#125;,<br>    &#123;46, <span class="hljs-string">&quot;sendmsg&quot;</span>&#125;,<br>    &#123;47, <span class="hljs-string">&quot;recvmsg&quot;</span>&#125;,<br>    &#123;48, <span class="hljs-string">&quot;shutdown&quot;</span>&#125;,<br>    &#123;49, <span class="hljs-string">&quot;bind&quot;</span>&#125;,<br>    &#123;50, <span class="hljs-string">&quot;listen&quot;</span>&#125;,<br>    &#123;51, <span class="hljs-string">&quot;getsockname&quot;</span>&#125;,<br>    &#123;52, <span class="hljs-string">&quot;getpeername&quot;</span>&#125;,<br>    &#123;53, <span class="hljs-string">&quot;socketpair&quot;</span>&#125;,<br>    &#123;54, <span class="hljs-string">&quot;setsockopt&quot;</span>&#125;,<br>    &#123;55, <span class="hljs-string">&quot;getsockopt&quot;</span>&#125;,<br>    &#123;56, <span class="hljs-string">&quot;clone&quot;</span>&#125;,<br>    &#123;57, <span class="hljs-string">&quot;fork&quot;</span>&#125;,<br>    &#123;58, <span class="hljs-string">&quot;vfork&quot;</span>&#125;,<br>    &#123;59, <span class="hljs-string">&quot;execve&quot;</span>&#125;,<br>    &#123;60, <span class="hljs-string">&quot;exit&quot;</span>&#125;,<br>    &#123;61, <span class="hljs-string">&quot;wait4&quot;</span>&#125;,<br>    &#123;62, <span class="hljs-string">&quot;kill&quot;</span>&#125;,<br>    &#123;63, <span class="hljs-string">&quot;uname&quot;</span>&#125;,<br>    &#123;64, <span class="hljs-string">&quot;semget&quot;</span>&#125;,<br>    &#123;65, <span class="hljs-string">&quot;semop&quot;</span>&#125;,<br>    &#123;66, <span class="hljs-string">&quot;semctl&quot;</span>&#125;,<br>    &#123;67, <span class="hljs-string">&quot;shmdt&quot;</span>&#125;,<br>    &#123;68, <span class="hljs-string">&quot;msgget&quot;</span>&#125;,<br>    &#123;69, <span class="hljs-string">&quot;msgsnd&quot;</span>&#125;,<br>    &#123;70, <span class="hljs-string">&quot;msgrcv&quot;</span>&#125;,<br>    &#123;71, <span class="hljs-string">&quot;msgctl&quot;</span>&#125;,<br>    &#123;72, <span class="hljs-string">&quot;fcntl&quot;</span>&#125;,<br>    &#123;73, <span class="hljs-string">&quot;flock&quot;</span>&#125;,<br>    &#123;74, <span class="hljs-string">&quot;fsync&quot;</span>&#125;,<br>    &#123;75, <span class="hljs-string">&quot;fdatasync&quot;</span>&#125;,<br>    &#123;76, <span class="hljs-string">&quot;truncate&quot;</span>&#125;,<br>    &#123;77, <span class="hljs-string">&quot;ftruncate&quot;</span>&#125;,<br>    &#123;78, <span class="hljs-string">&quot;getdents&quot;</span>&#125;,<br>    &#123;79, <span class="hljs-string">&quot;getcwd&quot;</span>&#125;,<br>    &#123;80, <span class="hljs-string">&quot;chdir&quot;</span>&#125;,<br>    &#123;81, <span class="hljs-string">&quot;fchdir&quot;</span>&#125;,<br>    &#123;82, <span class="hljs-string">&quot;rename&quot;</span>&#125;,<br>    &#123;83, <span class="hljs-string">&quot;mkdir&quot;</span>&#125;,<br>    &#123;84, <span class="hljs-string">&quot;rmdir&quot;</span>&#125;,<br>    &#123;85, <span class="hljs-string">&quot;creat&quot;</span>&#125;,<br>    &#123;86, <span class="hljs-string">&quot;link&quot;</span>&#125;,<br>    &#123;87, <span class="hljs-string">&quot;unlink&quot;</span>&#125;,<br>    &#123;88, <span class="hljs-string">&quot;symlink&quot;</span>&#125;,<br>    &#123;89, <span class="hljs-string">&quot;readlink&quot;</span>&#125;,<br>    &#123;90, <span class="hljs-string">&quot;chmod&quot;</span>&#125;,<br>    &#123;91, <span class="hljs-string">&quot;fchmod&quot;</span>&#125;,<br>    &#123;92, <span class="hljs-string">&quot;chown&quot;</span>&#125;,<br>    &#123;93, <span class="hljs-string">&quot;fchown&quot;</span>&#125;,<br>    &#123;94, <span class="hljs-string">&quot;lchown&quot;</span>&#125;,<br>    &#123;95, <span class="hljs-string">&quot;umask&quot;</span>&#125;,<br>    &#123;96, <span class="hljs-string">&quot;gettimeofday&quot;</span>&#125;,<br>    &#123;97, <span class="hljs-string">&quot;getrlimit&quot;</span>&#125;,<br>    &#123;98, <span class="hljs-string">&quot;getrusage&quot;</span>&#125;,<br>    &#123;99, <span class="hljs-string">&quot;sysinfo&quot;</span>&#125;,<br>    &#123;100, <span class="hljs-string">&quot;times&quot;</span>&#125;,<br>    &#123;101, <span class="hljs-string">&quot;ptrace&quot;</span>&#125;,<br>    &#123;102, <span class="hljs-string">&quot;getuid&quot;</span>&#125;,<br>    &#123;103, <span class="hljs-string">&quot;syslog&quot;</span>&#125;,<br>    &#123;104, <span class="hljs-string">&quot;getgid&quot;</span>&#125;,<br>    &#123;105, <span class="hljs-string">&quot;setuid&quot;</span>&#125;,<br>    &#123;106, <span class="hljs-string">&quot;setgid&quot;</span>&#125;,<br>    &#123;107, <span class="hljs-string">&quot;geteuid&quot;</span>&#125;,<br>    &#123;108, <span class="hljs-string">&quot;getegid&quot;</span>&#125;,<br>    &#123;109, <span class="hljs-string">&quot;setpgid&quot;</span>&#125;,<br>    &#123;110, <span class="hljs-string">&quot;getppid&quot;</span>&#125;,<br>    &#123;111, <span class="hljs-string">&quot;getpgrp&quot;</span>&#125;,<br>    &#123;112, <span class="hljs-string">&quot;setsid&quot;</span>&#125;,<br>    &#123;113, <span class="hljs-string">&quot;setreuid&quot;</span>&#125;,<br>    &#123;114, <span class="hljs-string">&quot;setregid&quot;</span>&#125;,<br>    &#123;115, <span class="hljs-string">&quot;getgroups&quot;</span>&#125;,<br>    &#123;116, <span class="hljs-string">&quot;setgroups&quot;</span>&#125;,<br>    &#123;117, <span class="hljs-string">&quot;setresuid&quot;</span>&#125;,<br>    &#123;118, <span class="hljs-string">&quot;getresuid&quot;</span>&#125;,<br>    &#123;119, <span class="hljs-string">&quot;setresgid&quot;</span>&#125;,<br>    &#123;120, <span class="hljs-string">&quot;getresgid&quot;</span>&#125;,<br>    &#123;121, <span class="hljs-string">&quot;getpgid&quot;</span>&#125;,<br>    &#123;122, <span class="hljs-string">&quot;setfsuid&quot;</span>&#125;,<br>    &#123;123, <span class="hljs-string">&quot;setfsgid&quot;</span>&#125;,<br>    &#123;124, <span class="hljs-string">&quot;getsid&quot;</span>&#125;,<br>    &#123;125, <span class="hljs-string">&quot;capget&quot;</span>&#125;,<br>    &#123;126, <span class="hljs-string">&quot;capset&quot;</span>&#125;,<br>    &#123;127, <span class="hljs-string">&quot;rt_sigpending&quot;</span>&#125;,<br>    &#123;128, <span class="hljs-string">&quot;rt_sigtimedwait&quot;</span>&#125;,<br>    &#123;129, <span class="hljs-string">&quot;rt_sigqueueinfo&quot;</span>&#125;,<br>    &#123;130, <span class="hljs-string">&quot;rt_sigsuspend&quot;</span>&#125;,<br>    &#123;131, <span class="hljs-string">&quot;sigaltstack&quot;</span>&#125;,<br>    &#123;132, <span class="hljs-string">&quot;utime&quot;</span>&#125;,<br>    &#123;133, <span class="hljs-string">&quot;mknod&quot;</span>&#125;,<br>    &#123;134, <span class="hljs-string">&quot;uselib&quot;</span>&#125;,<br>    &#123;135, <span class="hljs-string">&quot;personality&quot;</span>&#125;,<br>    &#123;136, <span class="hljs-string">&quot;ustat&quot;</span>&#125;,<br>    &#123;137, <span class="hljs-string">&quot;statfs&quot;</span>&#125;,<br>    &#123;138, <span class="hljs-string">&quot;fstatfs&quot;</span>&#125;,<br>    &#123;139, <span class="hljs-string">&quot;sysfs&quot;</span>&#125;,<br>    &#123;140, <span class="hljs-string">&quot;getpriority&quot;</span>&#125;,<br>    &#123;141, <span class="hljs-string">&quot;setpriority&quot;</span>&#125;,<br>    &#123;142, <span class="hljs-string">&quot;sched_setparam&quot;</span>&#125;,<br>    &#123;143, <span class="hljs-string">&quot;sched_getparam&quot;</span>&#125;,<br>    &#123;144, <span class="hljs-string">&quot;sched_setscheduler&quot;</span>&#125;,<br>    &#123;145, <span class="hljs-string">&quot;sched_getscheduler&quot;</span>&#125;,<br>    &#123;146, <span class="hljs-string">&quot;sched_get_priority_max&quot;</span>&#125;,<br>    &#123;147, <span class="hljs-string">&quot;sched_get_priority_min&quot;</span>&#125;,<br>    &#123;148, <span class="hljs-string">&quot;sched_rr_get_interval&quot;</span>&#125;,<br>    &#123;149, <span class="hljs-string">&quot;mlock&quot;</span>&#125;,<br>    &#123;150, <span class="hljs-string">&quot;munlock&quot;</span>&#125;,<br>    &#123;151, <span class="hljs-string">&quot;mlockall&quot;</span>&#125;,<br>    &#123;152, <span class="hljs-string">&quot;munlockall&quot;</span>&#125;,<br>    &#123;153, <span class="hljs-string">&quot;vhangup&quot;</span>&#125;,<br>    &#123;154, <span class="hljs-string">&quot;modify_ldt&quot;</span>&#125;,<br>    &#123;155, <span class="hljs-string">&quot;pivot_root&quot;</span>&#125;,<br>    &#123;156, <span class="hljs-string">&quot;_sysctl&quot;</span>&#125;,<br>    &#123;157, <span class="hljs-string">&quot;prctl&quot;</span>&#125;,<br>    &#123;158, <span class="hljs-string">&quot;arch_prctl&quot;</span>&#125;,<br>    &#123;159, <span class="hljs-string">&quot;adjtimex&quot;</span>&#125;,<br>    &#123;160, <span class="hljs-string">&quot;setrlimit&quot;</span>&#125;,<br>    &#123;161, <span class="hljs-string">&quot;chroot&quot;</span>&#125;,<br>    &#123;162, <span class="hljs-string">&quot;sync&quot;</span>&#125;,<br>    &#123;163, <span class="hljs-string">&quot;acct&quot;</span>&#125;,<br>    &#123;164, <span class="hljs-string">&quot;settimeofday&quot;</span>&#125;,<br>    &#123;165, <span class="hljs-string">&quot;mount&quot;</span>&#125;,<br>    &#123;166, <span class="hljs-string">&quot;umount2&quot;</span>&#125;,<br>    &#123;167, <span class="hljs-string">&quot;swapon&quot;</span>&#125;,<br>    &#123;168, <span class="hljs-string">&quot;swapoff&quot;</span>&#125;,<br>    &#123;169, <span class="hljs-string">&quot;reboot&quot;</span>&#125;,<br>    &#123;170, <span class="hljs-string">&quot;sethostname&quot;</span>&#125;,<br>    &#123;171, <span class="hljs-string">&quot;setdomainname&quot;</span>&#125;,<br>    &#123;172, <span class="hljs-string">&quot;iopl&quot;</span>&#125;,<br>    &#123;173, <span class="hljs-string">&quot;ioperm&quot;</span>&#125;,<br>    &#123;174, <span class="hljs-string">&quot;create_module&quot;</span>&#125;,<br>    &#123;175, <span class="hljs-string">&quot;init_module&quot;</span>&#125;,<br>    &#123;176, <span class="hljs-string">&quot;delete_module&quot;</span>&#125;,<br>    &#123;177, <span class="hljs-string">&quot;get_kernel_syms&quot;</span>&#125;,<br>    &#123;178, <span class="hljs-string">&quot;query_module&quot;</span>&#125;,<br>    &#123;179, <span class="hljs-string">&quot;quotactl&quot;</span>&#125;,<br>    &#123;180, <span class="hljs-string">&quot;nfsservctl&quot;</span>&#125;,<br>    &#123;181, <span class="hljs-string">&quot;getpmsg&quot;</span>&#125;,<br>    &#123;182, <span class="hljs-string">&quot;putpmsg&quot;</span>&#125;,<br>    &#123;183, <span class="hljs-string">&quot;afs_syscall&quot;</span>&#125;,<br>    &#123;184, <span class="hljs-string">&quot;tuxcall&quot;</span>&#125;,<br>    &#123;185, <span class="hljs-string">&quot;security&quot;</span>&#125;,<br>    &#123;186, <span class="hljs-string">&quot;gettid&quot;</span>&#125;,<br>    &#123;187, <span class="hljs-string">&quot;readahead&quot;</span>&#125;,<br>    &#123;188, <span class="hljs-string">&quot;setxattr&quot;</span>&#125;,<br>    &#123;189, <span class="hljs-string">&quot;lsetxattr&quot;</span>&#125;,<br>    &#123;190, <span class="hljs-string">&quot;fsetxattr&quot;</span>&#125;,<br>    &#123;191, <span class="hljs-string">&quot;getxattr&quot;</span>&#125;,<br>    &#123;192, <span class="hljs-string">&quot;lgetxattr&quot;</span>&#125;,<br>    &#123;193, <span class="hljs-string">&quot;fgetxattr&quot;</span>&#125;,<br>    &#123;194, <span class="hljs-string">&quot;listxattr&quot;</span>&#125;,<br>    &#123;195, <span class="hljs-string">&quot;llistxattr&quot;</span>&#125;,<br>    &#123;196, <span class="hljs-string">&quot;flistxattr&quot;</span>&#125;,<br>    &#123;197, <span class="hljs-string">&quot;removexattr&quot;</span>&#125;,<br>    &#123;198, <span class="hljs-string">&quot;lremovexattr&quot;</span>&#125;,<br>    &#123;199, <span class="hljs-string">&quot;fremovexattr&quot;</span>&#125;,<br>    &#123;200, <span class="hljs-string">&quot;tkill&quot;</span>&#125;,<br>    &#123;201, <span class="hljs-string">&quot;time&quot;</span>&#125;,<br>    &#123;202, <span class="hljs-string">&quot;futex&quot;</span>&#125;,<br>    &#123;203, <span class="hljs-string">&quot;sched_setaffinity&quot;</span>&#125;,<br>    &#123;204, <span class="hljs-string">&quot;sched_getaffinity&quot;</span>&#125;,<br>    &#123;205, <span class="hljs-string">&quot;set_thread_area&quot;</span>&#125;,<br>    &#123;206, <span class="hljs-string">&quot;io_setup&quot;</span>&#125;,<br>    &#123;207, <span class="hljs-string">&quot;io_destroy&quot;</span>&#125;,<br>    &#123;208, <span class="hljs-string">&quot;io_getevents&quot;</span>&#125;,<br>    &#123;209, <span class="hljs-string">&quot;io_submit&quot;</span>&#125;,<br>    &#123;210, <span class="hljs-string">&quot;io_cancel&quot;</span>&#125;,<br>    &#123;211, <span class="hljs-string">&quot;get_thread_area&quot;</span>&#125;,<br>    &#123;212, <span class="hljs-string">&quot;lookup_dcookie&quot;</span>&#125;,<br>    &#123;213, <span class="hljs-string">&quot;epoll_create&quot;</span>&#125;,<br>    &#123;214, <span class="hljs-string">&quot;epoll_ctl_old&quot;</span>&#125;,<br>    &#123;215, <span class="hljs-string">&quot;epoll_wait_old&quot;</span>&#125;,<br>    &#123;216, <span class="hljs-string">&quot;remap_file_pages&quot;</span>&#125;,<br>    &#123;217, <span class="hljs-string">&quot;getdents64&quot;</span>&#125;,<br>    &#123;218, <span class="hljs-string">&quot;set_tid_address&quot;</span>&#125;,<br>    &#123;219, <span class="hljs-string">&quot;restart_syscall&quot;</span>&#125;,<br>    &#123;220, <span class="hljs-string">&quot;semtimedop&quot;</span>&#125;,<br>    &#123;221, <span class="hljs-string">&quot;fadvise64&quot;</span>&#125;,<br>    &#123;222, <span class="hljs-string">&quot;timer_create&quot;</span>&#125;,<br>    &#123;223, <span class="hljs-string">&quot;timer_settime&quot;</span>&#125;,<br>    &#123;224, <span class="hljs-string">&quot;timer_gettime&quot;</span>&#125;,<br>    &#123;225, <span class="hljs-string">&quot;timer_getoverrun&quot;</span>&#125;,<br>    &#123;226, <span class="hljs-string">&quot;timer_delete&quot;</span>&#125;,<br>    &#123;227, <span class="hljs-string">&quot;clock_settime&quot;</span>&#125;,<br>    &#123;228, <span class="hljs-string">&quot;clock_gettime&quot;</span>&#125;,<br>    &#123;229, <span class="hljs-string">&quot;clock_getres&quot;</span>&#125;,<br>    &#123;230, <span class="hljs-string">&quot;clock_nanosleep&quot;</span>&#125;,<br>    &#123;231, <span class="hljs-string">&quot;exit_group&quot;</span>&#125;,<br>    &#123;232, <span class="hljs-string">&quot;epoll_wait&quot;</span>&#125;,<br>    &#123;233, <span class="hljs-string">&quot;epoll_ctl&quot;</span>&#125;,<br>    &#123;234, <span class="hljs-string">&quot;tgkill&quot;</span>&#125;,<br>    &#123;235, <span class="hljs-string">&quot;utimes&quot;</span>&#125;,<br>    &#123;236, <span class="hljs-string">&quot;vserver&quot;</span>&#125;,<br>    &#123;237, <span class="hljs-string">&quot;mbind&quot;</span>&#125;,<br>    &#123;238, <span class="hljs-string">&quot;set_mempolicy&quot;</span>&#125;,<br>    &#123;239, <span class="hljs-string">&quot;get_mempolicy&quot;</span>&#125;,<br>    &#123;240, <span class="hljs-string">&quot;mq_open&quot;</span>&#125;,<br>    &#123;241, <span class="hljs-string">&quot;mq_unlink&quot;</span>&#125;,<br>    &#123;242, <span class="hljs-string">&quot;mq_timedsend&quot;</span>&#125;,<br>    &#123;243, <span class="hljs-string">&quot;mq_timedreceive&quot;</span>&#125;,<br>    &#123;244, <span class="hljs-string">&quot;mq_notify&quot;</span>&#125;,<br>    &#123;245, <span class="hljs-string">&quot;mq_getsetattr&quot;</span>&#125;,<br>    &#123;246, <span class="hljs-string">&quot;kexec_load&quot;</span>&#125;,<br>    &#123;247, <span class="hljs-string">&quot;waitid&quot;</span>&#125;,<br>    &#123;248, <span class="hljs-string">&quot;add_key&quot;</span>&#125;,<br>    &#123;249, <span class="hljs-string">&quot;request_key&quot;</span>&#125;,<br>    &#123;250, <span class="hljs-string">&quot;keyctl&quot;</span>&#125;,<br>    &#123;251, <span class="hljs-string">&quot;ioprio_set&quot;</span>&#125;,<br>    &#123;252, <span class="hljs-string">&quot;ioprio_get&quot;</span>&#125;,<br>    &#123;253, <span class="hljs-string">&quot;inotify_init&quot;</span>&#125;,<br>    &#123;254, <span class="hljs-string">&quot;inotify_add_watch&quot;</span>&#125;,<br>    &#123;255, <span class="hljs-string">&quot;inotify_rm_watch&quot;</span>&#125;,<br>    &#123;256, <span class="hljs-string">&quot;migrate_pages&quot;</span>&#125;,<br>    &#123;257, <span class="hljs-string">&quot;openat&quot;</span>&#125;,<br>    &#123;258, <span class="hljs-string">&quot;mkdirat&quot;</span>&#125;,<br>    &#123;259, <span class="hljs-string">&quot;mknodat&quot;</span>&#125;,<br>    &#123;260, <span class="hljs-string">&quot;fchownat&quot;</span>&#125;,<br>    &#123;261, <span class="hljs-string">&quot;futimesat&quot;</span>&#125;,<br>    &#123;262, <span class="hljs-string">&quot;newfstatat&quot;</span>&#125;,<br>    &#123;263, <span class="hljs-string">&quot;unlinkat&quot;</span>&#125;,<br>    &#123;264, <span class="hljs-string">&quot;renameat&quot;</span>&#125;,<br>    &#123;265, <span class="hljs-string">&quot;linkat&quot;</span>&#125;,<br>    &#123;266, <span class="hljs-string">&quot;symlinkat&quot;</span>&#125;,<br>    &#123;267, <span class="hljs-string">&quot;readlinkat&quot;</span>&#125;,<br>    &#123;268, <span class="hljs-string">&quot;fchmodat&quot;</span>&#125;,<br>    &#123;269, <span class="hljs-string">&quot;faccessat&quot;</span>&#125;,<br>    &#123;270, <span class="hljs-string">&quot;pselect6&quot;</span>&#125;,<br>    &#123;271, <span class="hljs-string">&quot;ppoll&quot;</span>&#125;,<br>    &#123;272, <span class="hljs-string">&quot;unshare&quot;</span>&#125;,<br>    &#123;273, <span class="hljs-string">&quot;set_robust_list&quot;</span>&#125;,<br>    &#123;274, <span class="hljs-string">&quot;get_robust_list&quot;</span>&#125;,<br>    &#123;275, <span class="hljs-string">&quot;splice&quot;</span>&#125;,<br>    &#123;276, <span class="hljs-string">&quot;tee&quot;</span>&#125;,<br>    &#123;277, <span class="hljs-string">&quot;sync_file_range&quot;</span>&#125;,<br>    &#123;278, <span class="hljs-string">&quot;vmsplice&quot;</span>&#125;,<br>    &#123;279, <span class="hljs-string">&quot;move_pages&quot;</span>&#125;,<br>    &#123;280, <span class="hljs-string">&quot;utimensat&quot;</span>&#125;,<br>    &#123;281, <span class="hljs-string">&quot;epoll_pwait&quot;</span>&#125;,<br>    &#123;282, <span class="hljs-string">&quot;signalfd&quot;</span>&#125;,<br>    &#123;283, <span class="hljs-string">&quot;timerfd_create&quot;</span>&#125;,<br>    &#123;284, <span class="hljs-string">&quot;eventfd&quot;</span>&#125;,<br>    &#123;285, <span class="hljs-string">&quot;fallocate&quot;</span>&#125;,<br>    &#123;286, <span class="hljs-string">&quot;timerfd_settime&quot;</span>&#125;,<br>    &#123;287, <span class="hljs-string">&quot;timerfd_gettime&quot;</span>&#125;,<br>    &#123;288, <span class="hljs-string">&quot;accept4&quot;</span>&#125;,<br>    &#123;289, <span class="hljs-string">&quot;signalfd4&quot;</span>&#125;,<br>    &#123;290, <span class="hljs-string">&quot;eventfd2&quot;</span>&#125;,<br>    &#123;291, <span class="hljs-string">&quot;epoll_create1&quot;</span>&#125;,<br>    &#123;292, <span class="hljs-string">&quot;dup3&quot;</span>&#125;,<br>    &#123;293, <span class="hljs-string">&quot;pipe2&quot;</span>&#125;,<br>    &#123;294, <span class="hljs-string">&quot;inotify_init1&quot;</span>&#125;,<br>    &#123;295, <span class="hljs-string">&quot;preadv&quot;</span>&#125;,<br>    &#123;296, <span class="hljs-string">&quot;pwritev&quot;</span>&#125;,<br>    &#123;297, <span class="hljs-string">&quot;rt_tgsigqueueinfo&quot;</span>&#125;,<br>    &#123;298, <span class="hljs-string">&quot;perf_event_open&quot;</span>&#125;,<br>    &#123;299, <span class="hljs-string">&quot;recvmmsg&quot;</span>&#125;,<br>    &#123;300, <span class="hljs-string">&quot;fanotify_init&quot;</span>&#125;,<br>    &#123;301, <span class="hljs-string">&quot;fanotify_mark&quot;</span>&#125;,<br>    &#123;302, <span class="hljs-string">&quot;prlimit64&quot;</span>&#125;,<br>    &#123;303, <span class="hljs-string">&quot;name_to_handle_at&quot;</span>&#125;,<br>    &#123;304, <span class="hljs-string">&quot;open_by_handle_at&quot;</span>&#125;,<br>    &#123;305, <span class="hljs-string">&quot;clock_adjtime&quot;</span>&#125;,<br>    &#123;306, <span class="hljs-string">&quot;syncfs&quot;</span>&#125;,<br>    &#123;307, <span class="hljs-string">&quot;sendmmsg&quot;</span>&#125;,<br>    &#123;308, <span class="hljs-string">&quot;setns&quot;</span>&#125;,<br>    &#123;309, <span class="hljs-string">&quot;getcpu&quot;</span>&#125;,<br>    &#123;310, <span class="hljs-string">&quot;process_vm_readv&quot;</span>&#125;,<br>    &#123;311, <span class="hljs-string">&quot;process_vm_writev&quot;</span>&#125;,<br>    &#123;312, <span class="hljs-string">&quot;kcmp&quot;</span>&#125;,<br>    &#123;313, <span class="hljs-string">&quot;finit_module&quot;</span>&#125;,<br>    &#123;314, <span class="hljs-string">&quot;sched_setattr&quot;</span>&#125;,<br>    &#123;315, <span class="hljs-string">&quot;sched_getattr&quot;</span>&#125;,<br>    &#123;316, <span class="hljs-string">&quot;renameat2&quot;</span>&#125;,<br>    &#123;317, <span class="hljs-string">&quot;seccomp&quot;</span>&#125;,<br>    &#123;318, <span class="hljs-string">&quot;getrandom&quot;</span>&#125;,<br>    &#123;319, <span class="hljs-string">&quot;memfd_create&quot;</span>&#125;,<br>    &#123;320, <span class="hljs-string">&quot;kexec_file_load&quot;</span>&#125;,<br>    &#123;321, <span class="hljs-string">&quot;bpf&quot;</span>&#125;,<br>    &#123;322, <span class="hljs-string">&quot;execveat&quot;</span>&#125;,<br>    &#123;323, <span class="hljs-string">&quot;userfaultfd&quot;</span>&#125;,<br>    &#123;324, <span class="hljs-string">&quot;membarrier&quot;</span>&#125;,<br>    &#123;325, <span class="hljs-string">&quot;mlock2&quot;</span>&#125;,<br>    &#123;326, <span class="hljs-string">&quot;copy_file_range&quot;</span>&#125;,<br>    &#123;327, <span class="hljs-string">&quot;preadv2&quot;</span>&#125;,<br>    &#123;328, <span class="hljs-string">&quot;pwritev2&quot;</span>&#125;,<br>    &#123;329, <span class="hljs-string">&quot;pkey_mprotect&quot;</span>&#125;,<br>    &#123;330, <span class="hljs-string">&quot;pkey_alloc&quot;</span>&#125;,<br>    &#123;331, <span class="hljs-string">&quot;pkey_free&quot;</span>&#125;,<br>    &#123;332, <span class="hljs-string">&quot;statx&quot;</span>&#125;,<br>    &#123;333, <span class="hljs-string">&quot;io_pgetevents&quot;</span>&#125;,<br>    &#123;334, <span class="hljs-string">&quot;rseq&quot;</span>&#125;,<br>    &#123;424, <span class="hljs-string">&quot;pidfd_send_signal&quot;</span>&#125;,<br>    &#123;425, <span class="hljs-string">&quot;io_uring_setup&quot;</span>&#125;,<br>    &#123;426, <span class="hljs-string">&quot;io_uring_enter&quot;</span>&#125;,<br>    &#123;427, <span class="hljs-string">&quot;io_uring_register&quot;</span>&#125;,<br>    &#123;428, <span class="hljs-string">&quot;open_tree&quot;</span>&#125;,<br>    &#123;429, <span class="hljs-string">&quot;move_mount&quot;</span>&#125;,<br>    &#123;430, <span class="hljs-string">&quot;fsopen&quot;</span>&#125;,<br>    &#123;431, <span class="hljs-string">&quot;fsconfig&quot;</span>&#125;,<br>    &#123;432, <span class="hljs-string">&quot;fsmount&quot;</span>&#125;,<br>    &#123;433, <span class="hljs-string">&quot;fspick&quot;</span>&#125;,<br>    &#123;434, <span class="hljs-string">&quot;pidfd_open&quot;</span>&#125;,<br>    &#123;435, <span class="hljs-string">&quot;clone3&quot;</span>&#125;,<br>    &#123;436, <span class="hljs-string">&quot;close_range&quot;</span>&#125;,<br>    &#123;437, <span class="hljs-string">&quot;openat2&quot;</span>&#125;,<br>    &#123;438, <span class="hljs-string">&quot;pidfd_getfd&quot;</span>&#125;,<br>    &#123;439, <span class="hljs-string">&quot;faccessat2&quot;</span>&#125;,<br>    &#123;440, <span class="hljs-string">&quot;process_madvise&quot;</span>&#125;,<br>    &#123;512, <span class="hljs-string">&quot;rt_sigaction&quot;</span>&#125;,<br>    &#123;513, <span class="hljs-string">&quot;rt_sigreturn&quot;</span>&#125;,<br>    &#123;514, <span class="hljs-string">&quot;ioctl&quot;</span>&#125;,<br>    &#123;515, <span class="hljs-string">&quot;readv&quot;</span>&#125;,<br>    &#123;516, <span class="hljs-string">&quot;writev&quot;</span>&#125;,<br>    &#123;517, <span class="hljs-string">&quot;recvfrom&quot;</span>&#125;,<br>    &#123;518, <span class="hljs-string">&quot;sendmsg&quot;</span>&#125;,<br>    &#123;519, <span class="hljs-string">&quot;recvmsg&quot;</span>&#125;,<br>    &#123;520, <span class="hljs-string">&quot;execve&quot;</span>&#125;,<br>    &#123;521, <span class="hljs-string">&quot;ptrace&quot;</span>&#125;,<br>    &#123;522, <span class="hljs-string">&quot;rt_sigpending&quot;</span>&#125;,<br>    &#123;523, <span class="hljs-string">&quot;rt_sigtimedwait&quot;</span>&#125;,<br>    &#123;524, <span class="hljs-string">&quot;rt_sigqueueinfo&quot;</span>&#125;,<br>    &#123;525, <span class="hljs-string">&quot;sigaltstack&quot;</span>&#125;,<br>    &#123;526, <span class="hljs-string">&quot;timer_create&quot;</span>&#125;,<br>    &#123;527, <span class="hljs-string">&quot;mq_notify&quot;</span>&#125;,<br>    &#123;528, <span class="hljs-string">&quot;kexec_load&quot;</span>&#125;,<br>    &#123;529, <span class="hljs-string">&quot;waitid&quot;</span>&#125;,<br>    &#123;530, <span class="hljs-string">&quot;set_robust_list&quot;</span>&#125;,<br>    &#123;531, <span class="hljs-string">&quot;get_robust_list&quot;</span>&#125;,<br>    &#123;532, <span class="hljs-string">&quot;vmsplice&quot;</span>&#125;,<br>    &#123;533, <span class="hljs-string">&quot;move_pages&quot;</span>&#125;,<br>    &#123;534, <span class="hljs-string">&quot;preadv&quot;</span>&#125;,<br>    &#123;535, <span class="hljs-string">&quot;pwritev&quot;</span>&#125;,<br>    &#123;536, <span class="hljs-string">&quot;rt_tgsigqueueinfo&quot;</span>&#125;,<br>    &#123;537, <span class="hljs-string">&quot;recvmmsg&quot;</span>&#125;,<br>    &#123;538, <span class="hljs-string">&quot;sendmmsg&quot;</span>&#125;,<br>    &#123;539, <span class="hljs-string">&quot;process_vm_readv&quot;</span>&#125;,<br>    &#123;540, <span class="hljs-string">&quot;process_vm_writev&quot;</span>&#125;,<br>    &#123;541, <span class="hljs-string">&quot;setsockopt&quot;</span>&#125;,<br>    &#123;542, <span class="hljs-string">&quot;getsockopt&quot;</span>&#125;,<br>    &#123;543, <span class="hljs-string">&quot;io_setup&quot;</span>&#125;,<br>    &#123;544, <span class="hljs-string">&quot;io_submit&quot;</span>&#125;,<br>    &#123;545, <span class="hljs-string">&quot;execveat&quot;</span>&#125;,<br>    &#123;546, <span class="hljs-string">&quot;preadv2&quot;</span>&#125;,<br>    &#123;547, <span class="hljs-string">&quot;pwritev2&quot;</span>&#125;,<br>    &#123;-1, NULL&#125;,<br>&#125;;<br><br>char *find_syscall_symbol(int code) &#123;<br>    struct syscall *sc;<br><br>    <span class="hljs-keyword">for</span> (sc = syscall_table; sc-&gt;code &gt;= 0; sc++) &#123;<br>        <span class="hljs-keyword">if</span> (sc-&gt;code == code) &#123;<br>            <span class="hljs-built_in">return</span> sc-&gt;name;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> NULL;<br>&#125;<br><br>int main(int argc, char *argv[])<br>&#123;<br>    pid_t child;<br>    int status;<br>    struct user_regs_struct regs;<br>    int orig_rax;<br><br>    child = fork();<br>    <span class="hljs-keyword">if</span> (child == 0) &#123;<br>        ptrace(PTRACE_TRACEME, 0, NULL, NULL);<br>        execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;/bin/ls&quot;</span>, NULL);<br>        <span class="hljs-built_in">exit</span>(0);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">wait</span>(&amp;status); // 接收被子进程发送过来的 SIGCHLD 信号<br><br>        <span class="hljs-keyword">while</span> (1) &#123;<br>            // 1. 发送 PTRACE_SYSCALL 命令给被跟踪进程 (调用系统调用前，可以获取系统调用的参数)<br>            ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>            <span class="hljs-built_in">wait</span>(&amp;status); // 接收被子进程发送过来的 SIGCHLD 信号<br>            <span class="hljs-keyword">if</span>(WIFEXITED(status)) &#123; // 如果子进程退出了, 那么终止跟踪<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br><br>            ptrace(PTRACE_GETREGS, child, 0, &amp;regs); // 获取被跟踪进程寄存器的值<br><br>            orig_rax = regs.orig_rax; // 获取rax寄存器的值<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;syscall: %s()\n&quot;</span>, find_syscall_symbol(orig_rax)); // 打印rax寄存器的值<br><br>            // 2. 发送 PTRACE_SYSCALL 命令给被跟踪进程 (调用系统调用后，可以获取系统调用的返回值)<br>            ptrace(PTRACE_SYSCALL, child, NULL, NULL);<br><br>            <span class="hljs-built_in">wait</span>(&amp;status); // 接收被子进程发送过来的 SIGCHLD 信号<br>            <span class="hljs-keyword">if</span>(WIFEXITED(status)) &#123; // 如果子进程退出了, 那么终止跟踪<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android内存读写断点--mprotect</title>
    <link href="/2022/11/14/Android%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%AD%E7%82%B9-mprotect/"/>
    <url>/2022/11/14/Android%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%AD%E7%82%B9-mprotect/</url>
    
    <content type="html"><![CDATA[<p>这几天听朋友说 GG 可以在不加载驱动的情况下设置内存读写断点，类似 PC 上 ce 的 “查看谁访问了该内存” 功能。网上也查了下资料，发现其实不难.</p><p>简单来说，就是先注册一个异常处理函数，然后把内存属性设置为无法访问 (PROT_NONE), 然后当程序读取或改写这段内存后会触发异常，在异常处理函数里获取到 pc 寄存器的值后恢复内存属性即可.</p><ol><li>注册异常处理函数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">struct sigaction act ;<br>memset(&amp;act ,0 ,sizeof(act));<br>act.sa_sigaction = &amp;handler ; //异常处理函数<br>act.sa_flags =SA_SIGINFO |SA_RESETHAND|SA_NODEFER;<br>sigaction(SIGSEGV,&amp;act ,NULL); //注册异常处理函数,SIGSEGV表示读取或写入无效内存的错误类型<br>void handler (int sig ,siginfo_t *siginfo , void * context)&#123;<br>    //匹配我们要监控的地址<br>    <span class="hljs-keyword">if</span> (siginfo-&gt;si_addr==&amp;i)&#123;<br>        ucontext_t ctx=(*(ucontext_t*)context);<br>        LOGD(<span class="hljs-string">&quot;pc = 0x%llx \n&quot;</span>,ctx.uc_mcontext.pc); //查看是哪个代码访问了这段内存<br>    &#125;<br>    //还原原来内存的属性<br>    int pageSize = getpagesize();<br>    unsigned long addr= reinterpret_cast&lt;unsigned long&gt;(&amp;start);<br>    unsigned long mem = addr &amp; (~(pageSize - 1));<br>    LOGD(<span class="hljs-string">&quot;mprotect:%d&quot;</span>,mprotect(reinterpret_cast&lt;void *&gt;(mem), pageSize, PROT_READ|PROT_WRITE));<br>    <span class="hljs-built_in">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>设置要读取的内存的属性，注意这个内存必须按页对齐。这里以读取 i 为例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">int pageSize = getpagesize();<br>unsigned long addr= reinterpret_cast&lt;unsigned long&gt;(&amp;i);<br>start = addr &amp; (~(pageSize - 1)); //按页对齐,start表示对齐后的内存地址<br>LOGD(<span class="hljs-string">&quot;start：%p &quot;</span>,start);<br>LOGD(<span class="hljs-string">&quot;pageSize：%p &quot;</span>,pageSize);<br>LOGD(<span class="hljs-string">&quot;mprotect:%d&quot;</span>,mprotect(reinterpret_cast&lt;void *&gt;(start), pageSize, PROT_NONE)); //0表示成功,-1表示失败<br></code></pre></td></tr></table></figure>效果如下:<br><img src="/.com//../../img/0.png" alt="header"></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android内存读写检测</title>
    <link href="/2022/11/14/Android%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E6%A3%80%E6%B5%8B/"/>
    <url>/2022/11/14/Android%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="mincore检测原理"><a href="#mincore检测原理" class="headerlink" title="mincore检测原理"></a>mincore检测原理</h1><p>缺页异常比如我们调用 mmap 来映射内存，为了防止内存无效分配，该内存空间在未访问时是不会创建物理内存页的。当程序需要使用这块内存区域时，会触发缺页中断，然后系统才会创建物理内存页，就是先用 mmap 申请一段内存，如果 ce, 或 GG 读取这段内存后，那么这段内存就会由缺页变成非缺页，而内存的缺页与否可以通过调用 mincore 判断.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.mmap 申请内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">char * memory= nullptr;<br>memory= (char*)mmap(nullptr,0x4000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);<br></code></pre></td></tr></table></figure><p>如果不对 memory 进行读写，那么 memory 默认为缺页状态</p><p>2.mincore 判断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">int pageSize = getpagesize();<br>unsigned char vec = 0;<br>//memory[0]=1; 这个操作会把memory改为非缺页状态<br>unsigned long addr= reinterpret_cast&lt;unsigned long&gt;(memory);<br>unsigned long start = addr &amp; (~(pageSize - 1));<br>mincore((void *)start, pageSize, &amp;vec);<br><span class="hljs-keyword">if</span> (vec == 1)<br>&#123;<br>    LOGD(<span class="hljs-string">&quot;内存页：%p 存在于物理内存空间&quot;</span>,addr);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    LOGD(<span class="hljs-string">&quot;内存页：%p 不存在于物理内存空间&quot;</span>,addr);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>当 ce 指定读取该内存时，会发现该内存已经处于非缺页状态.</p><p>但是使用 ce 全局搜索内存时，并没有检测到这段内存.<br><img src="/.com//../../img/1.png" alt="header"></p><h1 id="inotify检测原理"><a href="#inotify检测原理" class="headerlink" title="inotify检测原理"></a>inotify检测原理</h1><p>app 里使用 inotify 机制监控对内存的读写操作，引用百度百科的一句话.</p><p>Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。</p><p>使用</p><ol><li>新建一个监控线程.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pthread_t ptMem, t, ptPageMap;<br>int iRet = 0;<br>iRet = pthread_create(&amp;ptPageMap, NULL, thread_watchInotifyDump, NULL);<br></code></pre></td></tr></table></figure></li><li>初始化监控<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">char dirName[NAME_MAX] = &#123;0&#125;;<br>//snprintf(dirName, NAME_MAX, <span class="hljs-string">&quot;/proc/%d&quot;</span>, getpid());<br><br>//用于监控/proc/pid/mem的数据<br>snprintf(dirName, NAME_MAX, <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, getpid());<br><br>LOGD(<span class="hljs-string">&quot;监控位置 : %s\n&quot;</span>, dirName);<br><br>int fd = inotify_init();<br><span class="hljs-keyword">if</span> (fd &lt; 0)<br>&#123;<br>    LOGE(<span class="hljs-string">&quot;inotify_init err.\n&quot;</span>);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br>int wd = inotify_add_watch(fd, dirName, IN_ALL_EVENTS);<br><span class="hljs-keyword">if</span> (wd &lt; 0)<br>&#123;<br><br>    LOGE(<span class="hljs-string">&quot;inotify_add_watch err.\n&quot;</span>);<br>    close(fd);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>3.select 读取监控消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">const int buflen = sizeof(struct inotify_event) * 0x100;<br>char buf[buflen] = &#123;0&#125;;<br>fd_set readfds;<br>int count[5] = &#123;0&#125;;<br><span class="hljs-keyword">while</span> (1)<br>&#123;<br>    FD_ZERO(&amp;readfds);<br>    FD_SET(fd, &amp;readfds);<br>    int iRet = select(fd + 1, &amp;readfds, 0, 0, 0); // 此处阻塞<br>    LOGD(<span class="hljs-string">&quot;iRet的返回值:%d\n&quot;</span>, iRet);<br>    <span class="hljs-keyword">if</span> (-1 == iRet)<br>        <span class="hljs-built_in">break</span>;<br>    <span class="hljs-keyword">if</span> (iRet)<br>    &#123;<br>        memset(buf, 0, buflen);<br>        int len = <span class="hljs-built_in">read</span>(fd, buf, buflen);<br>        int i = 0;<br>        <span class="hljs-keyword">while</span> (i &lt; len) &#123;<br>            struct inotify_event *event = (struct inotify_event *)&amp;buf[i];<br>            LOGD(<span class="hljs-string">&quot;event mask:%d\n&quot;</span>, event-&gt;mask);<br>            <span class="hljs-keyword">if</span> ((event-&gt;mask &amp; IN_ACCESS)) &#123;<br>                ++count[0];<br>                LOGD(<span class="hljs-string">&quot;1.IN_ACCESS,第%d次.\n\n&quot;</span>, count[0]);<br>                //__asm __volatile(<span class="hljs-string">&quot;.int 0x8c89fa98&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((event-&gt;mask &amp; IN_OPEN))&#123;<br>                ++count[1];<br>                LOGD(<span class="hljs-string">&quot;2.IN_OPEN,第%d次.\n\n&quot;</span>,  count[1]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((event-&gt;mask &amp; IN_CLOSE))&#123;<br>                ++count[2];<br>                LOGD(<span class="hljs-string">&quot;3.IN_CLOSE,第%d次.\n\n&quot;</span>, count[2]);<br>            &#125;<br>            i += sizeof(struct inotify_event) + event-&gt;len;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果<br>当用 ceserver 读取内存时。<br><img src="/.com//../../img/2.png" alt="header"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Magisk注入app并嵌入imgui</title>
    <link href="/2022/11/14/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui/"/>
    <url>/2022/11/14/Magisk%E6%B3%A8%E5%85%A5app%E5%B9%B6%E5%B5%8C%E5%85%A5imgui/</url>
    
    <content type="html"><![CDATA[<p>Android特殊绘制方框的方法</p><h2 id="Android特殊绘制方框的方法"><a href="#Android特殊绘制方框的方法" class="headerlink" title="Android特殊绘制方框的方法"></a>Android特殊绘制方框的方法</h2><p>需要关闭 selinux 并且要把 linker 和 libc 的路径分别改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/apex/com.android.runtime/bin/linker64<br>/apex/com.android.runtime/lib64/bionic/libc.so<br></code></pre></td></tr></table></figure><p>具体可以看这篇 github <a href="https://github.com/SsageParuders/AndroidPtraceInject">github</a></p><p>说回正题，既然 Surfaceflinger 进程没有 eglSwapBuffers 函数，那么 eglSwapBuffers 肯定是在 app 内部调用的，直接 hook 了 app 内部 eglSwapBuffers 函数就行.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">static void <span class="hljs-function"><span class="hljs-title">init_dobby</span></span>()<br>&#123;<br>    void *sym_eglSwapBuffers = DobbySymbolResolver(NULL, <span class="hljs-string">&quot;eglSwapBuffers&quot;</span>);<br>    <span class="hljs-keyword">if</span> (NULL != sym_eglSwapBuffers)<br>    &#123;<br>        LOGD(<span class="hljs-string">&quot;sym_eglSwapBuffers:%llx&quot;</span>, (unsigned long long)sym_eglSwapBuffers);<br>        DobbyHook(sym_eglSwapBuffers, (void *)new_eglSwapBuffers, (void **)&amp;ori_eglSwapBuffers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我这里选用 Dobby 的 hook 框架，参考了使用<a href="https://www.cnblogs.com/luoyesiqiu/p/magisk_riru.html#at?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">Magisk+riru 实现全局改机的用法.</a><br>在 hook 后的 new_eglSwapBuffers 里完成 imgui 的初始化，显示即可。基本上不需要怎么改动 imgui 的代码.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">IMGUI_CHECKVERSION();<br>ImGui::CreateContext();<br>ImGuiIO&amp; io = ImGui::GetIO();<br><br>// Disable loading/saving of .ini file from disk.<br>// FIXME: Consider using LoadIniSettingsFromMemory() / SaveIniSettingsToMemory() to save <span class="hljs-keyword">in</span> appropriate location <span class="hljs-keyword">for</span> Android.<br>io.IniFilename = NULL;<br><br>// Setup Dear ImGui style<br>ImGui::StyleColorsDark();<br>//ImGui::StyleColorsClassic();<br><br>// Setup Platform/Renderer backends<br>ImGui_ImplAndroid_Init(nullptr);<br>ImGui_ImplOpenGL3_Init(<span class="hljs-string">&quot;#version 300 es&quot;</span>);<br>g_Initialized = <span class="hljs-literal">true</span>;<br>.......<br></code></pre></td></tr></table></figure><p>之后用 Zygisk-ModuleTemplate 模板编译，magisk 安装就行.</p><p>不足之处:</p><ol><li>由于和游戏共用 surface, 如果绘制异常游戏直接闪退.</li><li>进行复杂绘制的时候会卡游戏画面，降低帧率.</li><li>兼容性差，不支持大部分的 ue4 引擎的游戏.</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ptrace注入so</title>
    <link href="/2022/06/27/ptrace%E6%B3%A8%E5%85%A5so/"/>
    <url>/2022/06/27/ptrace%E6%B3%A8%E5%85%A5so/</url>
    
    <content type="html"><![CDATA[<h1 id="So注入"><a href="#So注入" class="headerlink" title="So注入"></a>So注入</h1><p>so注入的主要思路是：<br>找到目标进程<br>使用ptrace跟踪目标进程，保存目标进程的状态<br>获得mmap、dlopen、dlsym等库函数在目标进程中的偏移地址<br>调用mmap在目标进程内部申请一段内存空间<br>将我们的ShellCode写入到刚才申请的内存空间中<br>dlopen打开Shellcode，dlsym调用Shellcode库的函数<br>恢复原so状态，detach</p><h1 id="核心点-ptrace"><a href="#核心点-ptrace" class="headerlink" title="核心点 ptrace"></a>核心点 ptrace</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;sys/ptrace.h&gt;</span><br><br>long ptrace（enum _ptrace_request request,pid_t pid,void * addr ,void *data）;<br><br>    1). enum __ptrace_request request：指示了ptrace要执行的命令。<br>    2). pid_t pid: 指示ptrace要跟踪的进程。<br>    3). void *addr: 指示要监控的内存地址。<br>    4). void *data: 存放读取出的或者要写入的数据。<br></code></pre></td></tr></table></figure><p>简单点，ptrace是个系统调用，功能是提供一个进程（父进程）监控和管理另一个进程（子进程）的能力，并允许父进程检查和替换子进程的内核镜像(包括寄存器)的值。</p><p>基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。</p><h2 id="ptrace命令"><a href="#ptrace命令" class="headerlink" title="ptrace命令"></a>ptrace命令</h2><p>1). 用PTRACE_ATTACH或者PTRACE_TRACEME 建立进程间的跟踪关系。<br>2). PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR等读取子进程内存&#x2F;寄存器中保留的值。<br>3). PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR等把值写入到被跟踪进程的内存&#x2F;寄存器中<br>4). 用PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP控制被跟踪进程以何种方式继续运行。<br>5). PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系。</p><p>TIPS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 进程状态TASK_TRACED用以表示当前进程因为被父进程跟踪而被系统停止。<br>2. 如在子进程结束前，父进程结束，则trace关系解除。<br>3. 利用attach建立起来的跟踪关系，虽然ps看到双方为父子关系，但在<span class="hljs-string">&quot;子进程&quot;</span>中调用getppid()仍会返回原来的父进程<span class="hljs-built_in">id</span>。<br>4. 不能attach到自己不能跟踪的进程，如non-root进程跟踪root进程。<br>5. 已经被trace的进程，不能再次被attach。<br>6. 即使是用PTRACE_TRACEME建立起来的跟踪关系，也可以用DETACH的方式予以解除。<br>7. 因为进入/退出系统调用都会触发一次SIGTRAP，所以通常的做法是在第一次(进入)的时候读取系统调用的参数，在第二次(退出)的时候读取系统调用的返回值。但注意execve是个例外。<br>8. 程序调试时的断点由int 3设置完成，而单步跟踪则可由ptrace(PTRACE_SINGLESTEP)实现。<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">switch(pid = fork())  <br>   &#123;  <br>   <span class="hljs-keyword">case</span> -1:  <br>       <span class="hljs-built_in">return</span> -1;  <br>   <span class="hljs-keyword">case</span> 0: //子进程  <br>       ptrace(PTRACE_TRACEME,0,NULL,NULL);  <br>       execl(<span class="hljs-string">&quot;./HelloWorld&quot;</span>, <span class="hljs-string">&quot;HelloWorld&quot;</span>, NULL);  <br>   default: //父进程  <br>       <span class="hljs-built_in">wait</span>(&amp;val); //等待并记录execve  <br>       <span class="hljs-keyword">if</span>(WIFEXITED(val))  <br>           <span class="hljs-built_in">return</span> 0;  <br>       syscallID=ptrace(PTRACE_PEEKUSER, pid, ORIG_EAX*4, NULL);  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process executed system call ID = %ld/n&quot;</span>,syscallID);  <br>       ptrace(PTRACE_SYSCALL,pid,NULL,NULL);  <br>   &#125;<br></code></pre></td></tr></table></figure><p>在上面的程序中，fork出的子进程先调用了ptrace(PTRACE_TRACEME)表示子进程让父进程跟踪自己。然后子进程调用execl加载执行了HelloWorld。</p><p>而在父进程中则使用wait系统调用等待子进程的中断或结束。子进程因为设置了PTRACE_TRACEME而在执行系统调用被系统停止(设置为TASK_TRACED)，这时父进程被唤醒，使用ptrace(PTRACE_PEEKUSER,pid,…)分别去读取子进程执行的系统调用ID(放在ORIG_EAX中)以及系统调用返回时的值(放在EAX中)。然后使用ptrace(PTRACE_SYSCALL,pid,…)指示子进程运行到下一次执行系统调用的时候(进入或者退出)，直到子进程退出为止。</p><p>wait指令会让父进程挂起，等待子进程的中断或结束</p><h1 id="断点原理"><a href="#断点原理" class="headerlink" title="断点原理"></a>断点原理</h1><p>断点是大家在调试程序时常用的一个功能,如break linenumber，当执行到linenumber那一行的时候被调试程序会停止，等待debugger的进一步操作。<br>断点的实现原理，就是在指定的位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并进行断点命中判定，当gdb判断出这次SIGTRAP是断点命中之后就会转入等待用户输入进行下一步处理，否则继续。</p><p>断点的设置原理: 在程序中设置断点，就是先将该位置的原来的指令保存，然后向该位置写入int 3。当执行到int 3的时候，发生软中断，内核会给子进程发出SIGTRAP信号，当然这个信号会被转发给父进程。然后用保存的指令替换int3,等待恢复运行。<br>断点命中判定:gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。</p><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><p>单步跟踪就是指在调试程序的时候，让程序运行一条指令&#x2F;语句后就停下。GDB中常用的命令有next, step, nexti, stepi。单步跟踪又常分为语句单步(next, step)和指令单步(如nexti, stepi)。</p><p>在linux上，指令单步可以通过ptrace来实现。调用ptrace(PTRACE_SINGLESTEP,pid,…)可以使被调试的进程在每执行完一条指令后就触发一个SIGTRAP信号，让GDB运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">child = fork();  <br>   <span class="hljs-keyword">if</span>(child == 0) &#123;  <br>        execl(<span class="hljs-string">&quot;./HelloWorld&quot;</span>, <span class="hljs-string">&quot;HelloWorld&quot;</span>, NULL);  <br>   &#125;  <br>   <span class="hljs-keyword">else</span> &#123;  <br>       ptrace(PTRACE_ATTACH,child,NULL,NULL);  <br>       <span class="hljs-keyword">while</span>(1)&#123;  <br>       <span class="hljs-built_in">wait</span>(&amp;val);  <br>       <span class="hljs-keyword">if</span>(WIFEXITED(val))  <br>           <span class="hljs-built_in">break</span>;  <br>       count++;  <br>       ptrace(PTRACE_SINGLESTEP,child,NULL,NULL);  <br>       &#125;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total Instruction number= %d/n&quot;</span>,count);  <br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="1、找到目标进程"><a href="#1、找到目标进程" class="headerlink" title="1、找到目标进程"></a>1、找到目标进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">pid_t target_pid;<br><br>// PS命令能找到的进程<br>target_pid = find_pid_of(<span class="hljs-string">&quot;/system/bin/logwrapper&quot;</span>);<br><span class="hljs-keyword">if</span> (-1 == target_pid) &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t find the process\n&quot;</span>);  <br>    <span class="hljs-built_in">return</span> -1;  <br>&#125;<br></code></pre></td></tr></table></figure><p>找到目标进程的实现方式为：通过proc文件系统来一一比较。</p><p>在Linux上，proc是一个伪文件系统，提供了访问内核数据的方法，一般挂载在“&#x2F;proc”目录</p><p>每个正在运行着的进程都proc下都会有个目录，目录名为pid。</p><p>例如init进程，它的pid为1，所以对应&#x2F;proc&#x2F;1&#x2F;，这个目录下保存的就是Init进程相关的数据。</p><p>找到目标进程的逻辑：</p><p>打开proc目录<br>读取该目录，并转为dirent<br>读取dirent-&gt;d_name值，并转为int号，也就是pid号<br>在循环遍历每一个读取到的pid目录下的cmdline，用\0’分割其中的字符串得到进程的args[]，拿到args[0]，也就是进程的绝对路径<br>匹配进程名是否一致</p><h3 id="dirent：是一个结构体，"><a href="#dirent：是一个结构体，" class="headerlink" title="dirent：是一个结构体，"></a>dirent：是一个结构体，</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">struct dirent<br>&#123;<br>  long d_ino; /* inode number 索引节点号 */<br>  off_t d_off; /* offset to this dirent 在目录文件中的偏移 */<br>  unsigned short d_reclen; /* length of this d_name 文件名长 */<br>  unsigned char d_type; /* the <span class="hljs-built_in">type</span> of d_name 文件类型 */<br>  char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长256字符 */<br>&#125;<br></code></pre></td></tr></table></figure><p>cmdline：存储的是main方法用的参数，也就是args，args[0]就是进程的绝对路径</p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">int find_pid_of(const char *process_name)    <br>&#123;    <br>    int <span class="hljs-built_in">id</span>;    <br>    pid_t pid = -1;    <br>    DIR* <span class="hljs-built_in">dir</span>;    <br>    FILE *fp;    <br>    char filename[32];    <br>    char cmdline[256];    <br>    <br>    struct dirent * entry;    <br>    <br>    <span class="hljs-keyword">if</span> (process_name == NULL)    <br>        <span class="hljs-built_in">return</span> -1;    <br>    <br>    <span class="hljs-built_in">dir</span> = opendir(<span class="hljs-string">&quot;/proc&quot;</span>);    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dir</span> == NULL)    <br>        <span class="hljs-built_in">return</span> -1;    <br>    <br>    <span class="hljs-keyword">while</span>((entry = readdir(<span class="hljs-built_in">dir</span>)) != NULL) &#123;    <br>        <span class="hljs-built_in">id</span> = atoi(entry-&gt;d_name);    <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">id</span> != 0) &#123;    <br>            sprintf(filename, <span class="hljs-string">&quot;/proc/%d/cmdline&quot;</span>, <span class="hljs-built_in">id</span>);    <br>            fp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>);    <br>            <span class="hljs-keyword">if</span> (fp) &#123;    <br>                fgets(cmdline, sizeof(cmdline), fp);    <br>                fclose(fp);    <br>    <br>                <span class="hljs-keyword">if</span> (strcmp(process_name, cmdline) == 0) &#123;    <br>                    /* process found */    <br>                    pid = <span class="hljs-built_in">id</span>;    <br>                    <span class="hljs-built_in">break</span>;    <br>                &#125;    <br>            &#125;    <br>        &#125;    <br>    &#125;    <br>    <br>    closedir(<span class="hljs-built_in">dir</span>);    <br>    <span class="hljs-built_in">return</span> pid;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、ptrace跟踪目标进程"><a href="#2、ptrace跟踪目标进程" class="headerlink" title="2、ptrace跟踪目标进程"></a>2、ptrace跟踪目标进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> (ptrace_attach(target_pid) == -1)   <br>&#123; <br>    goto <span class="hljs-built_in">exit</span>;    <br>&#125;<br><br>int ptrace_attach(pid_t pid)    <br>&#123;    <br>    <span class="hljs-keyword">if</span> (ptrace(PTRACE_ATTACH, pid, NULL, 0) &lt; 0) &#123;    <br>        perror(<span class="hljs-string">&quot;ptrace_attach&quot;</span>);    <br>        <span class="hljs-built_in">return</span> -1;    <br>    &#125;    <br>    <br>    int status = 0;    <br>    // 挂起父进程，等待子进程中断或结束<br>    waitpid(pid, &amp;status , WUNTRACED);    <br>    <br>    <span class="hljs-built_in">return</span> 0;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、保存目标进程寄存器的值"><a href="#3、保存目标进程寄存器的值" class="headerlink" title="3、保存目标进程寄存器的值"></a>3、保存目标进程寄存器的值</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == -1) <br>&#123;   <br>    goto <span class="hljs-built_in">exit</span>;    <br>&#125;<br><br>// 将读取到的寄存器值存放在regs中<br>int ptrace_getregs(pid_t pid, struct pt_regs * regs)    <br>&#123;    <br>    <span class="hljs-keyword">if</span> (ptrace(PTRACE_GETREGS, pid, NULL, regs) &lt; 0) &#123;    <br>        perror(<span class="hljs-string">&quot;ptrace_getregs: Can not get register values&quot;</span>);    <br>        <span class="hljs-built_in">return</span> -1;    <br>    &#125;    <br>    <br>    <span class="hljs-built_in">return</span> 0;    <br>&#125; <br><br>/* save original registers */    <br>memcpy(&amp;original_regs, &amp;regs, sizeof(regs));<br><br></code></pre></td></tr></table></figure><h2 id="4、获得mmap、dlopen等库函数在目标进程中的偏移地址"><a href="#4、获得mmap、dlopen等库函数在目标进程中的偏移地址" class="headerlink" title="4、获得mmap、dlopen等库函数在目标进程中的偏移地址"></a>4、获得mmap、dlopen等库函数在目标进程中的偏移地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">const char *linker_path = <span class="hljs-string">&quot;/system/bin/linker&quot;</span>;   <br><br>mmap_addr = get_remote_addr(target_pid, libc_path, (void *)mmap);<br>dlopen_addr = get_remote_addr( target_pid, linker_path, (void *)dlopen );    <br>dlsym_addr = get_remote_addr( target_pid, linker_path, (void *)dlsym );    <br>dlclose_addr = get_remote_addr( target_pid, linker_path, (void *)dlclose );    <br>dlerror_addr = get_remote_addr( target_pid, linker_path, (void *)dlerror );<br></code></pre></td></tr></table></figure><p>在计算偏移地址时，有个小TIPS，一个相同的库对于不同的进程来说，它的偏移量是恒定的。</p><p>也就是说，A进程载入了mmap，B进程也载入了mmap，那么mmap在A进程中的偏移等于相对于B进程的偏移。</p><h2 id="B-mmap地址-x3D-B-lib库地址-（A-mmap地址-A-lib库地址）"><a href="#B-mmap地址-x3D-B-lib库地址-（A-mmap地址-A-lib库地址）" class="headerlink" title="B.mmap地址 &#x3D; B_lib库地址 + （A.mmap地址 -A_lib库地址）"></a>B.mmap地址 &#x3D; B_lib库地址 + （A.mmap地址 -A_lib库地址）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">void* get_remote_addr(pid_t target_pid, const char* module_name, void* local_addr)    <br>&#123;    <br>    void* local_handle, *remote_handle;    <br>    <br>    local_handle = get_module_base(-1, module_name);    <br>    remote_handle = get_module_base(target_pid, module_name);    <br>    <br>    DEBUG_PRINT(<span class="hljs-string">&quot;[+] get_remote_addr: local[%x], remote[%x]\n&quot;</span>, local_handle, remote_handle);    <br>    <br>    void * ret_addr = (void *)((uint32_t)local_addr + (uint32_t)remote_handle - (uint32_t)local_handle);    <br>    <br><span class="hljs-comment">#if defined(__i386__)    </span><br>    <span class="hljs-keyword">if</span> (!strcmp(module_name, libc_path)) &#123;    <br>        ret_addr += 2;    <br>    &#125;    <br><span class="hljs-comment">#endif    </span><br>    <span class="hljs-built_in">return</span> ret_addr;    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">void* get_module_base(pid_t pid, const char* module_name)    <br>&#123;    <br>    FILE *fp;    <br>    long addr = 0;    <br>    char *pch;    <br>    char filename[32];    <br>    char line[1024];    <br>    <br>    <span class="hljs-keyword">if</span> (pid &lt; 0) &#123;    <br>        /* self process */    <br>        snprintf(filename, sizeof(filename), <span class="hljs-string">&quot;/proc/self/maps&quot;</span>, pid);    <br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        snprintf(filename, sizeof(filename), <span class="hljs-string">&quot;/proc/%d/maps&quot;</span>, pid);    <br>    &#125;    <br>    <br>    fp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>);    <br>    <br>    <span class="hljs-keyword">if</span> (fp != NULL) &#123;    <br>        <span class="hljs-keyword">while</span> (fgets(line, sizeof(line), fp)) &#123;    <br>            <span class="hljs-keyword">if</span> (strstr(line, module_name)) &#123;    <br>                pch = strtok( line, <span class="hljs-string">&quot;-&quot;</span> );    <br>                addr = strtoul( pch, NULL, 16 );    <br>    <br>                <span class="hljs-keyword">if</span> (addr == 0x8000)    <br>                    addr = 0;    <br>    <br>                <span class="hljs-built_in">break</span>;    <br>            &#125;    <br>        &#125;    <br>    <br>        fclose(fp) ;    <br>    &#125;    <br>    <br>    <span class="hljs-built_in">return</span> (void *)addr;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、调用mmap在目标进程申请内存空间"><a href="#5、调用mmap在目标进程申请内存空间" class="headerlink" title="5、调用mmap在目标进程申请内存空间"></a>5、调用mmap在目标进程申请内存空间</h2><p>构建mmap调用需要的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">/* call mmap */    <br>parameters[0] = 0;  // addr    <br>parameters[1] = 0x4000; // size    <br>parameters[2] = PROT_READ | PROT_WRITE | PROT_EXEC;  // prot    <br>parameters[3] =  MAP_ANONYMOUS | MAP_PRIVATE; // flags    <br>parameters[4] = 0; //fd    <br>parameters[5] = 0; //offset    <br><br><span class="hljs-keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="hljs-string">&quot;mmap&quot;</span>, mmap_addr, parameters, 6, &amp;regs) == -1)  <br>&#123;<br>    goto <span class="hljs-built_in">exit</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">int ptrace_call_wrapper(pid_t target_pid, const char * func_name, void * func_addr, long * parameters, int param_num, struct pt_regs * regs)     <br>&#123;    <br>  DEBUG_PRINT(<span class="hljs-string">&quot;[+] Calling %s in target process.\n&quot;</span>, func_name);    <br>  <span class="hljs-keyword">if</span> (ptrace_call(target_pid, (uint32_t)func_addr, parameters, param_num, regs) == -1)    <br>      <span class="hljs-built_in">return</span> -1;    <br><br>  <span class="hljs-keyword">if</span> (ptrace_getregs(target_pid, regs) == -1)    <br>      <span class="hljs-built_in">return</span> -1;    <br>  DEBUG_PRINT(<span class="hljs-string">&quot;[+] Target process returned from %s, return value=%x, pc=%x \n&quot;</span>,     <br>          func_name, ptrace_retval(regs), ptrace_ip(regs));    <br>  <span class="hljs-built_in">return</span> 0;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里做个平台判断，区分arm和x86，他们的实现方式不一样。下面只介绍arm</p><p>首先将前面构建的mmap参数放入寄存器当中，对于arm来说，R0~R3是存放参数的，对于超过4位的参数一律放在栈中<br>将目标进程的PC寄存器指向mmap的函数地址，重置CPSR状态寄存器，重置LR寄存器<br>将配置完的寄存器应用到进程中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#if defined(__arm__)    </span><br>int ptrace_call(pid_t pid, uint32_t addr, long *params, uint32_t num_params, struct pt_regs* regs)    <br>&#123;    <br>    uint32_t i;   <br>  // 参数先放寄存器中，R0~R3<br>    <span class="hljs-keyword">for</span> (i = 0; i &lt; num_params &amp;&amp; i &lt; 4; i ++) &#123;    <br>        regs-&gt;uregs[i] = params[i];    <br>    &#125;    <br>    <br>    // 多于4位的放在栈中   <br>    <span class="hljs-keyword">if</span> (i &lt; num_params) &#123;    <br>        regs-&gt;ARM_sp -= (num_params - i) * sizeof(long) ;    <br>        ptrace_writedata(pid, (void *)regs-&gt;ARM_sp, (uint8_t *)&amp;params[i], (num_params - i) * sizeof(long));    <br>    &#125;    <br>    <br>  // 将ARM的PC寄存器指向addr，也就是上面传来的需要调用的函数地址<br>    regs-&gt;ARM_pc = addr;    <br>  <br>    // 判断ARM当前所处的状态是thumb还是arm，它们的区别在于thumb是16位，arm是32位。属于arm的子集<br>    // 然后重置CPSR程序状态寄存器<br>    <span class="hljs-keyword">if</span> (regs-&gt;ARM_pc &amp; 1) &#123;    <br>        /* thumb */    <br>        regs-&gt;ARM_pc &amp;= (~1u);    <br>        regs-&gt;ARM_cpsr |= CPSR_T_MASK;    <br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        /* arm */    <br>        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;    <br>    &#125;    <br>    <br>    // 重置LR寄存器<br>    // LR寄存器存放的是子程序的返回地址<br>    regs-&gt;ARM_lr = 0;        <br>    <br>  // 设置寄存器的值<br>    <span class="hljs-keyword">if</span> (ptrace_setregs(pid, regs) == -1     <br>            || ptrace_continue(pid) == -1) &#123;    <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);    <br>        <span class="hljs-built_in">return</span> -1;    <br>    &#125;    <br>    <br>    int <span class="hljs-built_in">stat</span> = 0;  <br>    waitpid(pid, &amp;<span class="hljs-built_in">stat</span>, WUNTRACED);  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">stat</span> != 0xb7f) &#123;  <br>        <span class="hljs-keyword">if</span> (ptrace_continue(pid) == -1) &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);  <br>            <span class="hljs-built_in">return</span> -1;  <br>        &#125;  <br>        waitpid(pid, &amp;<span class="hljs-built_in">stat</span>, WUNTRACED);  <br>    &#125;  <br>    <br>    <span class="hljs-built_in">return</span> 0;    <br>&#125;    <br>    <br><span class="hljs-comment">#elif defined(__i386__)    </span><br>long ptrace_call(pid_t pid, uint32_t addr, long *params, uint32_t num_params, struct user_regs_struct * regs)    <br>&#123;    <br>    regs-&gt;esp -= (num_params) * sizeof(long) ;    <br>    ptrace_writedata(pid, (void *)regs-&gt;esp, (uint8_t *)params, (num_params) * sizeof(long));    <br>    <br>    long tmp_addr = 0x00;    <br>    regs-&gt;esp -= sizeof(long);    <br>    ptrace_writedata(pid, regs-&gt;esp, (char *)&amp;tmp_addr, sizeof(tmp_addr));     <br>    <br>    regs-&gt;eip = addr;    <br>    <br>    <span class="hljs-keyword">if</span> (ptrace_setregs(pid, regs) == -1     <br>            || ptrace_continue( pid) == -1) &#123;    <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);    <br>        <span class="hljs-built_in">return</span> -1;    <br>    &#125;    <br>    <br>    int <span class="hljs-built_in">stat</span> = 0;  <br>    waitpid(pid, &amp;<span class="hljs-built_in">stat</span>, WUNTRACED);  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">stat</span> != 0xb7f) &#123;  <br>        <span class="hljs-keyword">if</span> (ptrace_continue(pid) == -1) &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);  <br>            <span class="hljs-built_in">return</span> -1;  <br>        &#125;  <br>        waitpid(pid, &amp;<span class="hljs-built_in">stat</span>, WUNTRACED);  <br>    &#125;  <br>    <br>    <span class="hljs-built_in">return</span> 0;    <br>&#125;    <br><span class="hljs-comment">#else     </span><br><span class="hljs-comment">#error &quot;Not supported&quot;</span><br><span class="hljs-comment">#endif</span><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">int ptrace_writedata(pid_t pid, uint8_t *dest, uint8_t *data, size_t size)    <br>&#123;    <br>    uint32_t i, j, remain;    <br>    uint8_t *laddr;    <br>    <br>    union u &#123;    <br>        long val;    <br>        char chars[sizeof(long)];    <br>    &#125; d;    <br>    <br>    j = size / 4;    <br>    remain = size % 4;    <br>    <br>    laddr = data;    <br>    <br>    <span class="hljs-keyword">for</span> (i = 0; i &lt; j; i ++) &#123;    <br>        memcpy(d.chars, laddr, 4);    <br>        ptrace(PTRACE_POKETEXT, pid, dest, d.val);    <br>    <br>        dest  += 4;    <br>        laddr += 4;    <br>    &#125;    <br>    <br>    <span class="hljs-keyword">if</span> (remain &gt; 0) &#123;    <br>        d.val = ptrace(PTRACE_PEEKTEXT, pid, dest, 0);    <br>        <span class="hljs-keyword">for</span> (i = 0; i &lt; remain; i ++) &#123;    <br>            d.chars[i] = *laddr ++;    <br>        &#125;    <br>    <br>        ptrace(PTRACE_POKETEXT, pid, dest, d.val);    <br>    &#125;    <br>    <br>    <span class="hljs-built_in">return</span> 0;    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 设置寄存器<br>int ptrace_setregs(pid_t pid, struct pt_regs * regs)    <br>&#123;    <br>    <span class="hljs-keyword">if</span> (ptrace(PTRACE_SETREGS, pid, NULL, regs) &lt; 0) &#123;    <br>        perror(<span class="hljs-string">&quot;ptrace_setregs: Can not set register values&quot;</span>);    <br>        <span class="hljs-built_in">return</span> -1;    <br>    &#125;    <br>    <br>    <span class="hljs-built_in">return</span> 0;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写入Shellcode"><a href="#写入Shellcode" class="headerlink" title="写入Shellcode"></a>写入Shellcode</h2><p>首先拿到mmap映射的基地址，方便后续操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">map_base = ptrace_retval(&amp;regs);   <br>long ptrace_retval(struct pt_regs * regs)    <br>&#123;    <br><span class="hljs-comment">#if defined(__arm__)    </span><br>    <span class="hljs-built_in">return</span> regs-&gt;ARM_r0;    <br><span class="hljs-comment">#elif defined(__i386__)    </span><br>    <span class="hljs-built_in">return</span> regs-&gt;eax;    <br><span class="hljs-comment">#else    </span><br><span class="hljs-comment">#error &quot;Not supported&quot;    </span><br><span class="hljs-comment">#endif    </span><br>&#125;<br></code></pre></td></tr></table></figure><p>将我们的Shellcode写入到目标进程中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ptrace_writedata(target_pid, map_base, library_path, strlen(library_path) + 1);<br></code></pre></td></tr></table></figure><h2 id="6、执行Shellcode"><a href="#6、执行Shellcode" class="headerlink" title="6、执行Shellcode"></a>6、执行Shellcode</h2><p>构建dlopen的执行参数，打开shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">parameters[0] = map_base;       <br>parameters[1] = RTLD_NOW| RTLD_GLOBAL;     <br><br><span class="hljs-keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="hljs-string">&quot;dlopen&quot;</span>, dlopen_addr, parameters, 2, &amp;regs) == -1)  <br>&#123;<br>goto <span class="hljs-built_in">exit</span>;     <br>&#125;<br></code></pre></td></tr></table></figure><p>拿到shellcode的句柄，找到shellcode中目标方法的偏移地址，执行dlsym加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">void * sohandle = ptrace_retval(&amp;regs); <br><br><span class="hljs-comment">#define FUNCTION_NAME_ADDR_OFFSET       0x100    </span><br>    ptrace_writedata(target_pid, map_base + FUNCTION_NAME_ADDR_OFFSET, function_name, strlen(function_name) + 1);    <br>    parameters[0] = sohandle;       <br>    parameters[1] = map_base + FUNCTION_NAME_ADDR_OFFSET;     <br>    <br>    <span class="hljs-keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="hljs-string">&quot;dlsym&quot;</span>, dlsym_addr, parameters, 2, &amp;regs) == -1)    <br>        goto <span class="hljs-built_in">exit</span>;    <br>    <br>    void * hook_entry_addr = ptrace_retval(&amp;regs);    <br>    DEBUG_PRINT(<span class="hljs-string">&quot;hook_entry_addr = %p\n&quot;</span>, hook_entry_addr);    <br>    <br><span class="hljs-comment">#define FUNCTION_PARAM_ADDR_OFFSET      0x200    </span><br>    ptrace_writedata(target_pid, map_base + FUNCTION_PARAM_ADDR_OFFSET, param, strlen(param) + 1);    <br>    parameters[0] = map_base + FUNCTION_PARAM_ADDR_OFFSET;      <br>  <br>    <span class="hljs-keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="hljs-string">&quot;hook_entry&quot;</span>, hook_entry_addr, parameters, 1, &amp;regs) == -1)    <br>        goto <span class="hljs-built_in">exit</span>;<br></code></pre></td></tr></table></figure><h2 id="7、恢复原so的状态，detach"><a href="#7、恢复原so的状态，detach" class="headerlink" title="7、恢复原so的状态，detach"></a>7、恢复原so的状态，detach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Press enter to dlclose and detach\n&quot;</span>);    <br>getchar();    <br>parameters[0] = sohandle;       <br><br><span class="hljs-keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="hljs-string">&quot;dlclose&quot;</span>, dlclose, parameters, 1, &amp;regs) == -1)    <br>    goto <span class="hljs-built_in">exit</span>;    <br><br>/* restore */    <br>ptrace_setregs(target_pid, &amp;original_regs);    <br>ptrace_detach(target_pid);    <br>ret = 0;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">int ptrace_detach(pid_t pid)    <br>&#123;    <br>    <span class="hljs-keyword">if</span> (ptrace(PTRACE_DETACH, pid, NULL, 0) &lt; 0) &#123;    <br>        perror(<span class="hljs-string">&quot;ptrace_detach&quot;</span>);    <br>        <span class="hljs-built_in">return</span> -1;    <br>    &#125;    <br>    <br>    <span class="hljs-built_in">return</span> 0;    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Frida工作原理学习</title>
    <link href="/2022/06/26/Frida%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/06/26/Frida%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="frida介绍"><a href="#frida介绍" class="headerlink" title="frida介绍"></a>frida介绍</h1><p>frida是一款便携的,自由的,支持全平台的,hook框架，可以通过编写JavaScript,Python代码来和frida_server端进行交互,还记得当年用xposed时那种写了一大堆代码每次修改都要重新打包安装重启手机,那种调试调到头皮发麻的痛苦百分之30的时间都是在那里安装重启安装重启直到有一天遇到了小甜甜。</p><h1 id="frida的代码结构"><a href="#frida的代码结构" class="headerlink" title="frida的代码结构"></a>frida的代码结构</h1><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">frida-core</span><span class="hljs-punctuation">: </span>Frida 核心库<br><span class="hljs-attribute">frida-gum</span><span class="hljs-punctuation">: </span>inline-hook 框架<br><span class="hljs-attribute">bindings</span><span class="hljs-punctuation">: </span><br><span class="hljs-attribute">frida-python</span><span class="hljs-punctuation">: </span>python<br><span class="hljs-attribute">frida-node</span><span class="hljs-punctuation">: </span>Node.js<br><span class="hljs-attribute">frida-qml</span><span class="hljs-punctuation">: </span>Qml<br><span class="hljs-attribute">frida-swift</span><span class="hljs-punctuation">: </span>Swift<br><span class="hljs-attribute">frida-tools</span><span class="hljs-punctuation">: </span>CLI tools<br><span class="hljs-attribute">capstone</span><span class="hljs-punctuation">: </span>instruction disammbler<br></code></pre></td></tr></table></figure><p>Frida的核心是c编写的有多种语言绑定例如 Node.js、 Python、 Swift、 .NET、 Qml<br>一般我们都使用js去编写frida脚本因为js的异常处理机制非常棒相比于其他语言更高效好用。</p><h2 id="frida-core"><a href="#frida-core" class="headerlink" title="frida-core"></a>frida-core</h2><p>frida-core的功能有进程注入、进程间通信、会话管理、脚本生命周期管理等功能，屏蔽部分底层的实现细节并给最终用户提供开箱即用的操作接口。而这一切的实现都在 frida-core 之中，正如名字所言，这其中包含了 frida 相关的大部分关键模块和组件，比如 frida-server、frida-gadget、frida-agent、frida-helper、frida-inject 以及之间的互相通信底座。</p><h2 id="frida-gum"><a href="#frida-gum" class="headerlink" title="frida-gum"></a>frida-gum</h2><p>frida-gum是基于inline-hook实现的他还有很多丰富的功能比如用于代码跟踪 Stalker、用于内存访问监控的MemoryAccessMonitor，以及符号查找、栈回溯实现、内存扫描、动态代码生成和重定位等。</p><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p>Interceptor 是 inline-hook 的封装</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">GumInterceptor * <span class="hljs-built_in">int</span>erceptor;<br>GumInvocationListener * listener;<br>gum_init ();<br><span class="hljs-built_in">int</span>erceptor = gum_interceptor_obtain ();<br><span class="hljs-comment">//GumInvocationListener*的接口</span><br>listener = g_object_new (EXAMPLE_TYPE_LISTENER, NULL);<br><br><span class="hljs-comment">// 开始 hook `open` 函数</span><br>gum_interceptor_begin_transaction (<span class="hljs-built_in">int</span>erceptor);<br>gum_interceptor_attach_listener (<span class="hljs-built_in">int</span>erceptor,<br>      GSIZE_TO_POINTER (gum_module_find_export_by_name (NULL, <span class="hljs-string">&quot;open&quot;</span>)),<br>      listener,<br>      GSIZE_TO_POINTER (EXAMPLE_HOOK_OPEN));<br>gum_interceptor_end_transaction (<span class="hljs-built_in">int</span>erceptor);<br><br><span class="hljs-comment">// 测试 hook 效果</span><br>close (open (<span class="hljs-string">&quot;/etc/hosts&quot;</span>, O_RDONLY));<br><br><span class="hljs-comment">// 结束 hook</span><br>gum_interceptor_detach_listener (<span class="hljs-built_in">int</span>erceptor, listener);<br>g_object_unref (listener);<br>g_object_unref (<span class="hljs-built_in">int</span>erceptor);<br></code></pre></td></tr></table></figure><h3 id="Stalker"><a href="#Stalker" class="headerlink" title="Stalker"></a>Stalker</h3><p>潜行者又称为尾行痴汉，可以实现指定线程中所有函数、所有基本块、甚至所有指令的跟踪但是有很大的缺点比如在32位或者thumb下问题很大,一般想使用指令跟踪都是使用内存断点或者unidbg模拟执行so但是有很多问题，内存断点的反调试倒是很容易解决但是性能是一个很大的缺陷代码触发断点后会先中断到内核态，然后再返回到用户态(调试器)执行跟踪回调，处理完后再返回内核态，然后再回到用户态继续执行，这来来回回的黄花菜都凉了。但Unidbg的使用门槛动不动就补环境，龙哥说样本和Unidbg之间摩擦出的火花才是最迷人的。或者说人话——“他妈的Unidbg怎么又报错了，我该怎么办？”</p><p>Stalker的简单使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">Interceptor.attach(addr, &#123;<br>       onEnter: <span class="hljs-keyword">function</span> (args) &#123;<br>           this.args0 = args[<span class="hljs-number">0</span>];<br>           this.tid = Process.getCurrentThreadId();<br>           <span class="hljs-regexp">//</span>跟随<br>           Stalker.follow(this.tid, &#123;<br>               events: &#123;<span class="hljs-regexp">//</span>事件<br>                   call: true,<span class="hljs-regexp">//</span>呼叫<br>                   ret: false,<span class="hljs-regexp">//</span>返回<br>                   exec: true,<span class="hljs-regexp">//</span>执行<br>                   block: false,<span class="hljs-regexp">//</span>块<br>                   compile: false<span class="hljs-regexp">//</span>编译<br>               &#125;,<br>               <span class="hljs-regexp">//</span>接收<br>               onReceive(events)&#123;<br>                   <span class="hljs-keyword">for</span> (const [index,value] of Stalker.parse(events)) &#123;<br>                       console.log(index,value);<br>                       <span class="hljs-regexp">//</span>findModuleByAddress    &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;libc.so&quot;</span>,<span class="hljs-string">&quot;base&quot;</span>:<span class="hljs-string">&quot;0x7d1f0af000&quot;</span>,<span class="hljs-string">&quot;size&quot;</span>:<span class="hljs-number">3178496</span>,<span class="hljs-string">&quot;path&quot;</span>:<span class="hljs-string">&quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;</span>&#125;<br>                       <span class="hljs-regexp">//</span>console.log(<span class="hljs-string">&quot;tuzi&quot;</span>,Process.findModuleByAddress(<span class="hljs-number">0</span>x7d1f13adb8));<br><br>                   &#125;<br>               &#125;<br>               <span class="hljs-regexp">//</span> onCallSummary(summay)&#123;<br>               <span class="hljs-regexp">//</span>console.log(<span class="hljs-string">&quot;onCallSummary&quot;</span>+JSON.stringify(summay));<br>               <span class="hljs-regexp">//</span> &#125;,<br>           &#125;);<br>       &#125;, onLeave: <span class="hljs-keyword">function</span> (retval) &#123;<br>           Stalker.unfollow(this.tid);<br>       &#125;<br>   &#125;);<br></code></pre></td></tr></table></figure><p>Stalker也可以用来还原ollvm混淆 记录函数的真实执行地址结合ida反汇编没执行的代码都nop掉可以很大程度上帮助辅助混淆算法分析当然可能不太准确但也是一种非常棒的思路。<br>Stalker的功能实现，在线程即将执行下一条指令前，先将目标指令拷贝一份到新建的内存中，然后在新的内存中对代码进行插桩，如下图所示:<br> <img src="/.com//attach/202206/928079_YEHQKX7ZAKAH3UQ.png"><br>这其中使用到了代码动态重编译的方法，好处是原本的代码没有被修改，因此即便代码有完整性校验也不影响，另外由于执行过程都在用户态，省去了多次中断内核切换，性能损耗也达到了可以接受的水平。由于代码的位置发生了改变，如前文 Interceptor 一样，同样要对代码进行重定位的修复</p><h3 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h3><p>MemoryAccessMonitor可以实现对指定内存区间的访问监控，在目标内存区间发生读写行为时可以触发用户指定的回调函数。</p><p>通过阅读源码发现这个功能的实现方法非常简洁，本质上是将目标内存页设置为不可读写，这样在发生读写行为时会触发事先注册好的中断处理函数，其中会调用到用户使用 gum_memory_access_monitor_new 注册的回调方法中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//C 代码</span><br>gboolean<br><span class="hljs-title function_ invoke__">gum_memory_access_monitor_enable</span> (GumMemoryAccessMonitor * <span class="hljs-keyword">self</span>,<br>                                  GError ** error)<br>&#123;<br>  <span class="hljs-title function_ invoke__">if</span> (<span class="hljs-keyword">self</span><span class="hljs-punctuation">-&gt;</span>enabled)<br>    <span class="hljs-keyword">return</span> TRUE;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">self</span><span class="hljs-punctuation">-&gt;</span>exceptor = <span class="hljs-title function_ invoke__">gum_exceptor_obtain</span> ();<br>  <span class="hljs-title function_ invoke__">gum_exceptor_add</span> (<span class="hljs-keyword">self</span><span class="hljs-punctuation">-&gt;</span>exceptor, gum_memory_access_monitor_on_exception,<br>      <span class="hljs-keyword">self</span>);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//js代码</span><br><span class="hljs-keyword">function</span> read<span class="hljs-constructor">_write_break()</span>&#123;<br>    <span class="hljs-keyword">function</span> hook<span class="hljs-constructor">_dlopen(<span class="hljs-params">addr</span>, <span class="hljs-params">soName</span>, <span class="hljs-params">callback</span>)</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Interceptor</span>.</span></span>attach(addr, &#123;<br>            onEnter: <span class="hljs-keyword">function</span> (args) &#123;<br>                var soPath = args<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.read<span class="hljs-constructor">CString()</span>;<br>                <span class="hljs-keyword">if</span>(soPath.index<span class="hljs-constructor">Of(<span class="hljs-params">soName</span>)</span> != -<span class="hljs-number">1</span>) hook<span class="hljs-constructor">_call_constructors()</span>;<br>            &#125;, onLeave: <span class="hljs-keyword">function</span> (retval) &#123;<br>            &#125;<br>        &#125;);<br>    &#125;<br>    var dlopen = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Module</span>.</span></span>find<span class="hljs-constructor">ExportByName(<span class="hljs-string">&quot;libdl.so&quot;</span>, <span class="hljs-string">&quot;dlopen&quot;</span>)</span>;<br>    var android_dlopen_ext = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Module</span>.</span></span>find<span class="hljs-constructor">ExportByName(<span class="hljs-string">&quot;libdl.so&quot;</span>, <span class="hljs-string">&quot;android_dlopen_ext&quot;</span>)</span>;<br>    hook<span class="hljs-constructor">_dlopen(<span class="hljs-params">dlopen</span>, <span class="hljs-string">&quot;libaes.so&quot;</span>, <span class="hljs-params">set_read_write_break</span>)</span>;<br>    hook<span class="hljs-constructor">_dlopen(<span class="hljs-params">android_dlopen_ext</span>, <span class="hljs-string">&quot;libaes.so&quot;</span>, <span class="hljs-params">set_read_write_break</span>)</span>;<br><br>    <span class="hljs-keyword">function</span> set<span class="hljs-constructor">_read_write_break()</span>&#123;<br>        <span class="hljs-comment">//实现一个异常回调   处理好这个异常就可以正常返回</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Process</span>.</span></span>set<span class="hljs-constructor">ExceptionHandler(<span class="hljs-params">function</span>(<span class="hljs-params">details</span>)</span> &#123;<br>            console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>stringify(details, null, <span class="hljs-number">2</span>));<br>            console.log(<span class="hljs-string">&quot;lr&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DebugSymbol</span>.</span></span>from<span class="hljs-constructor">Address(<span class="hljs-params">details</span>.<span class="hljs-params">context</span>.<span class="hljs-params">lr</span>)</span>);<br>            console.log(<span class="hljs-string">&quot;pc&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DebugSymbol</span>.</span></span>from<span class="hljs-constructor">Address(<span class="hljs-params">details</span>.<span class="hljs-params">context</span>.<span class="hljs-params">pc</span>)</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memory</span>.</span></span>protect(details.memory.address, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Process</span>.</span></span>pointerSize, &#x27;rwx&#x27;);<br>            console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>backtrace(details.context, Backtracer.ACCURATE).map(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DebugSymbol</span>.</span></span>fromAddress).join(<span class="hljs-character">&#x27;\n&#x27;</span>) + <span class="hljs-character">&#x27;\n&#x27;</span>);<br>            return <span class="hljs-literal">true</span>;<br>        &#125;);<br>        var addr = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Module</span>.</span></span>find<span class="hljs-constructor">BaseAddress(<span class="hljs-string">&quot;libaes.so&quot;</span>)</span>.add(<span class="hljs-number">0x6666</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memory</span>.</span></span>protect(addr, <span class="hljs-number">8</span>, &#x27;---&#x27;); <span class="hljs-comment">//修改内存页的权限</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 比如有一个地址是0x12345678  我想看一下是那个代码去访问了这个地址</span><br><span class="hljs-comment">         * 我只需要把这个内存地址置空 有函数去访问这个地址时 就会触发非法访问异常</span><br><span class="hljs-comment">         * 比较鸡肋这种方法 这种方法会一次修改一个内存页  并且触发一次就无效了</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hook原理"><a href="#hook原理" class="headerlink" title="hook原理"></a>hook原理</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-number">1</span>.注入进程<br>ptrace<br>dlopen<br><span class="hljs-number">2</span>.hook 目标函数<br><span class="hljs-number">2.1</span> Java Hook<br><span class="hljs-keyword">Static</span> Field Hook：静态成员hook<br><span class="hljs-keyword">Method</span> <span class="hljs-title function_">Hook</span>：函数<span class="hljs-title function_">hook</span><br>2.2 <span class="hljs-title function_">Native</span> <span class="hljs-title function_">So</span> <span class="hljs-title function_">Hook</span><br><span class="hljs-title function_">GOT</span> <span class="hljs-title function_">Hook</span>：全局偏移表<span class="hljs-title function_">hook</span><br><span class="hljs-title function_">SYM</span> <span class="hljs-title function_">Hook</span>：符号表<span class="hljs-title function_">hook</span><br><span class="hljs-title function_">Inline</span> <span class="hljs-title function_">Hook</span>：函数内联<span class="hljs-title function_">hook</span><br>执行自身代码<br>获取敏感信息<br>修改返回值<br><span class="hljs-title function_">etc</span>.<br></code></pre></td></tr></table></figure><p>frida注入的主要思路就是找到目标进程,使用ptrace跟踪目标进程获取mmap，dlpoen，dlsym等函数库的便宜获取mmap在目标进程申请一段内存空间将在目标进程中找到存放[frida-agent-32&#x2F;64.so]的空间启动执行各种操作由agent去实现。<br>补充：frida注入之后会在远端进程分配一段内存将agent拷贝过去并在目标进程中执行代码，执行完成后会 detach 目标进程，这也是为什么在 frida 先连接上目标进程后还可以用gdb&#x2F;ida等调试器连接，而先gdb连接进程后 frida 就无法再次连上的原因(frida在注入时只会ptrace一下下注入完毕后就会结束ptrace所以ptrace占坑这种反调试使用spawn方式启动即可)。</p><p>frida-agent 注入到目标进程并启动后会启动一个新进程与 host 进行通信，从而 host 可以给目标进行发送命令，比如执行代码，激活&#x2F;关闭 hook，同时也能接收到目标进程的执行返回以及异步事件信息等。</p><h3 id="hook-java层"><a href="#hook-java层" class="headerlink" title="hook java层"></a>hook java层</h3><p>frida 的 hook 区分了 art 模式和 dalvik 模式。</p><h4 id="dalvik-模式"><a href="#dalvik-模式" class="headerlink" title="dalvik 模式"></a>dalvik 模式</h4><p>把 java 函数变成 native 函数，然后修改入口信息为自定义函数信息。<br><img src="/.com//../../img/13.png" alt="header"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> Method &#123;   <br>    ClassObject*    clazz;   <span class="hljs-comment">/* method所属的类 public、native等*/</span><br>    u4              accessFlags; <span class="hljs-comment">/* 访问标记 */</span><br>    u2             methodIndex; <span class="hljs-comment">//method索引</span><br>    <span class="hljs-comment">//三个size为边界值，对于native函数，这3个size均等于参数列表的size</span><br>    u2              registersSize;  <span class="hljs-comment">/* ins + locals */</span><br>    u2              outsSize;<br>    u2              insSize;<br>    const <span class="hljs-built_in">char</span>*     name;<span class="hljs-comment">//函数名称</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Method prototype descriptor string (return and argument types)</span><br><span class="hljs-comment">     */</span><br>    DexProto        prototype;<br>    <span class="hljs-comment">/* short-form method descriptor string */</span><br>    const <span class="hljs-built_in">char</span>*     shorty;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * The remaining items are not used for abstract or native methods.</span><br><span class="hljs-comment">     * (JNI is currently hijacking &quot;insns&quot; as a function pointer, set</span><br><span class="hljs-comment">     * after the first call.  For internal-native this stays null.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/* the actual code */</span><br>    const u2*       insns;          <span class="hljs-comment">/* instructions, in memory-mapped .dex */</span><br>    <span class="hljs-comment">/* cached JNI argument and return-type hints */</span><br>    <span class="hljs-built_in">int</span>             jniArgInfo;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Native method ptr; could be actual function or a JNI bridge.  We</span><br><span class="hljs-comment">     * don&#x27;t currently discriminate between DalvikBridgeFunc and</span><br><span class="hljs-comment">     * DalvikNativeFunc; the former takes an argument superset (i.e. two</span><br><span class="hljs-comment">     * extra args) which will be ignored.  If necessary we can use</span><br><span class="hljs-comment">     * insns==NULL to detect JNI bridge vs. internal native.</span><br><span class="hljs-comment">     */</span><br>    DalvikBridgeFunc nativeFunc;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Register map data, if available.  This will point into the DEX file</span><br><span class="hljs-comment">     * if the data was computed during pre-verification, or into the</span><br><span class="hljs-comment">     * linear alloc area if not.</span><br><span class="hljs-comment">     */</span><br>    const RegisterMap* registerMap;<br><br>&#125;;<br><br>…<br>…<br>…<br><br><span class="hljs-keyword">function</span> replaceDalvikImplementation (fn) &#123;<br>  <span class="hljs-keyword">if</span> (fn<span class="hljs-operator"> === </span>null<span class="hljs-operator"> &amp;&amp; </span>dalvikOriginalMethod<span class="hljs-operator"> === </span>null) &#123;<br>    return;<br>  &#125;<br><span class="hljs-comment">//备份原来的method,</span><br>  <span class="hljs-keyword">if</span> (dalvikOriginalMethod<span class="hljs-operator"> === </span>null) &#123;<br>    dalvikOriginalMethod = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memory</span>.</span></span>dup(methodId, DVM_METHOD_SIZE);<br>    dalvikTargetMethodId = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memory</span>.</span></span>dup(methodId, DVM_METHOD_SIZE);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (fn !== null) &#123;<br>   <span class="hljs-comment">//自定的代码</span><br>    implementation = implement(f, fn);<br><br>    <span class="hljs-keyword">let</span> argsSize = argTypes.reduce((acc, t) =&gt; (acc + t.size), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span><span class="hljs-operator"> === </span>INSTANCE_METHOD) &#123;<br>      argsSize++;<br>    &#125;<br>    <span class="hljs-comment">// 把method变成native函数</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * make method native (with kAccNative)</span><br><span class="hljs-comment">     * insSize and registersSize are set to arguments size</span><br><span class="hljs-comment">     */</span><br>    const accessFlags = (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memory</span>.</span></span>read<span class="hljs-constructor">U32(<span class="hljs-params">methodId</span>.<span class="hljs-params">add</span>(DVM_METHOD_OFFSET_ACCESS_FLAGS)</span>) <span class="hljs-pattern-match">| k<span class="hljs-constructor">AccNative</span>) &gt;&gt;&gt; 0;</span><br><span class="hljs-pattern-match">    const registers<span class="hljs-constructor">Size</span> = args<span class="hljs-constructor">Size</span>;</span><br><span class="hljs-pattern-match">    const outs<span class="hljs-constructor">Size</span> = 0;</span><br><span class="hljs-pattern-match">    const ins<span class="hljs-constructor">Size</span> = args<span class="hljs-constructor">Size</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Memory</span>.write<span class="hljs-constructor">U32(<span class="hljs-params">methodId</span>.<span class="hljs-params">add</span>(DVM_METHOD_OFFSET_ACCESS_FLAGS)</span>, access<span class="hljs-constructor">Flags</span>);</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Memory</span>.write<span class="hljs-constructor">U16(<span class="hljs-params">methodId</span>.<span class="hljs-params">add</span>(DVM_METHOD_OFFSET_REGISTERS_SIZE)</span>, registers<span class="hljs-constructor">Size</span>);</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Memory</span>.write<span class="hljs-constructor">U16(<span class="hljs-params">methodId</span>.<span class="hljs-params">add</span>(DVM_METHOD_OFFSET_OUTS_SIZE)</span>, outs<span class="hljs-constructor">Size</span>);</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Memory</span>.write<span class="hljs-constructor">U16(<span class="hljs-params">methodId</span>.<span class="hljs-params">add</span>(DVM_METHOD_OFFSET_INS_SIZE)</span>, ins<span class="hljs-constructor">Size</span>);</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Memory</span>.write<span class="hljs-constructor">U32(<span class="hljs-params">methodId</span>.<span class="hljs-params">add</span>(DVM_METHOD_OFFSET_JNI_ARG_INFO)</span>, compute<span class="hljs-constructor">DalvikJniArgInfo(<span class="hljs-params">methodId</span>)</span>);</span><br><span class="hljs-pattern-match">    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>调用dvm<span class="hljs-constructor">UseJNIBridge</span>为这个<span class="hljs-constructor">Method</span>设置一个<span class="hljs-constructor">Bridge</span>,本质上是修改结构体中的native<span class="hljs-constructor">Func</span>为自定义的implementation函数</span><br><span class="hljs-pattern-match">    api.dvm<span class="hljs-constructor">UseJNIBridge(<span class="hljs-params">methodId</span>, <span class="hljs-params">implementation</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    patched<span class="hljs-constructor">Methods</span>.add(f);</span><br><span class="hljs-pattern-match">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="hljs-pattern-match">    patched<span class="hljs-constructor">Methods</span>.delete(f);</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Memory</span>.copy(<span class="hljs-keyword">method</span><span class="hljs-constructor">Id</span>, dalvik<span class="hljs-constructor">OriginalMethod</span>, <span class="hljs-constructor">DVM_METHOD_SIZE</span>);</span><br><span class="hljs-pattern-match">    implementation = null;</span><br><span class="hljs-pattern-match">  &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="art-模式"><a href="#art-模式" class="headerlink" title="art 模式"></a>art 模式</h4><p>art模式也是需要将java 函数变成 native 函数但是不同于dalvik，art下有两种解释器一种汇编解释器一种smali解释器</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">quick</span> <span class="hljs-meta">code</span> 模式：执行 <span class="hljs-meta">arm</span> 汇编指令<br><span class="hljs-symbol">Interpreter</span> 模式：由解释器解释执行 Dalvik 字节码<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;2022.7.17 寒冰大佬指出问题  安卓7.0 有三种解释器switch结构，goto跳转表，汇编</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">enum InterpreterImplKind &#123;<br>   kSwitchImplKind,        <span class="hljs-regexp">//</span> Switch-based interpreter implementation.<br>   kComputedGotoImplKind,  <span class="hljs-regexp">//</span> Computed-goto-based interpreter implementation.<br>   kMterpImplKind          <span class="hljs-regexp">//</span> Assembly interpreter<br> &#125;;<br></code></pre></td></tr></table></figure><p><img src="/.com//../../img/14.png" alt="header"><br>1.如果函数已经存在quick code, 则指向这个函数对应的 quick code的起始地址，而当quick code不存在时，它的值则会代表其他的意义。</p><p>2.当一个 java 函数不存在 quick code时，它的值是函数artQuickToInterpreterBridge 的地址，用以从 quick 模式切换到 Interpreter 模式来解释执行 java 函数代码。</p><p>3.当一个 java native（JNI）函数不存在 quick code时，它的值是函数 art_quick_generic_jni_trampoline 的地址，用以执行没有quick code的 jni 函数。</p><p>所以 frida 要将 java method 转为 native method，需要将ARTMethod 结构进行如下修改：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">patchMethod(methodId, &#123;<br>  <span class="hljs-regexp">//</span>jnicode入口entry_point_from_jni_改为自定义的代码<br>  <span class="hljs-string">&#x27;jniCode&#x27;</span>: implementation,<br>  <span class="hljs-regexp">//</span>修改为access_flags_为native<br>  <span class="hljs-string">&#x27;accessFlags&#x27;</span>: (Memory.readU32(methodId.add(artMethodOffset.accessFlags)) | kAccNative | kAccFastNative) &gt;&gt;&gt; <span class="hljs-number">0</span>,<br>  <span class="hljs-regexp">//</span>art_quick_generic_jni_trampoline函数的地址<br>  <span class="hljs-string">&#x27;quickCode&#x27;</span>: api.artQuickGenericJniTrampoline,<br>  <span class="hljs-regexp">//</span>artInterpreterToCompiledCodeBridge函数地址<br>  <span class="hljs-string">&#x27;interpreterCode&#x27;</span>: api.artInterpreterToCompiledCodeBridge<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>evilpan.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/05/</span>frida-internal/<br>https:<span class="hljs-regexp">//</span>blog.drov.com.cn<span class="hljs-regexp">/2021/</span><span class="hljs-number">04</span>/hook.html<br>https:<span class="hljs-regexp">//</span>bbs.pediy.com/thread-<span class="hljs-number">229215</span>.htm<br>https:<span class="hljs-regexp">//</span>frida.re<span class="hljs-regexp">/docs/</span>home/<br>https:<span class="hljs-regexp">//</span>www.youtube.com/watch?v=uc1mbN9EJKQ<br><br></code></pre></td></tr></table></figure><h1 id="添加补充"><a href="#添加补充" class="headerlink" title="添加补充"></a>添加补充</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">2022.7</span>.<span class="hljs-number">17</span><br>一个非常不错的项目 纯frida实现的smali追踪<br>trace smali代码一般都是通过修改art源码去强制解析执行然后记录执行的指令和寄存器的值 <br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/SeeFlowerX/</span>frida-smali-trace<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录一次编译内核，修改内核源码监控系统调用</title>
    <link href="/2022/06/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2022/06/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次编译内核修改内核源码监控系统调用"><a href="#记录一次编译内核修改内核源码监控系统调用" class="headerlink" title="记录一次编译内核修改内核源码监控系统调用"></a>记录一次编译内核修改内核源码监控系统调用</h1><p>最近看了很多很好的贴子啊<br>SVC的TraceHook沙箱的实现&amp;无痕Hook实现思路<a href="https://bbs.pediy.com/thread-273160.htm">https://bbs.pediy.com/thread-273160.htm</a><br>Android通用svc跟踪以及hook方案——Frida-Seccomp<br><a href="https://bbs.pediy.com/thread-271815.htm">https://bbs.pediy.com/thread-271815.htm</a><br>又菜又想搞svc，就只能做最简单无脑的了  </p><h2 id="一，-给小白介绍一下什么是系统调用-syscall"><a href="#一，-给小白介绍一下什么是系统调用-syscall" class="headerlink" title="一，  给小白介绍一下什么是系统调用(syscall)"></a>一，  给小白介绍一下什么是系统调用(syscall)</h2><p>简单的来说呢就是libc.so里面的一些系统函数比如read(),write()最简单的读写函数，这些函数实际上底层都是由syscall()交给linux内核去实现的<br><img src="/.com//../../img/3.png" alt="header"><br><img src="/.com//../../img/4.png" alt="header"><br>他的第一个参数是系统调用号，后面的参数是根据调用的函数来写的<br>现在用android studio开发的话使用系统调用和使用正常的函数一样也不需要去<br>记这些系统调用号都有一个常量表可以很方便的去实现功能<br><img src="/.com//../../img/5.png" alt="header"><br><img src="/.com//../../img/6.png" alt="header"><br>在调用syscall时通过会从用户态切换到内核态<br><img src="/.com//../../img/7.png" alt="header"><br>正常使用hook框架很难去hook到内核态下的代码 常规手段可以通过找到svc指令地址 在他调用svc之前去inlinehook他效率以及一些别的问题 导致局限性非常大 </p><h2 id="二，-编译内核步骤"><a href="#二，-编译内核步骤" class="headerlink" title="二，  编译内核步骤"></a>二，  编译内核步骤</h2><p>1.去谷歌的官方文档查看自己机型的内核源码的目录<br><a href="https://source.android.com/setup/building-kernels">https://source.android.com/setup/building-kernels</a><br>我的是Pixel 3a XL (bonito)  也就是 bonito-kernel<br>这里在谷歌官方下载的话太慢了我选择去中科大下载<br>命令 ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone http:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/aosp/</span>kernel/msm.git<br><span class="hljs-regexp">//</span>下载完成后cd 到sms 目录 在链接手机在终端输入<br>cat <span class="hljs-regexp">/proc/</span>version<br>Linux version <span class="hljs-number">4.9</span>.<span class="hljs-number">165</span>-g583404d31612-ab5723792<br><span class="hljs-regexp">//</span>这一串<span class="hljs-number">583404</span>d31612 这个是我们需要的<br>git branch -r --contains <span class="hljs-number">583404</span>d31612 <br><span class="hljs-regexp">//</span>获取到我们需要的版本号<br></code></pre></td></tr></table></figure><p><img src="/.com//../../img/8.png" alt="header"><br>检出了那么一大堆 随意挑选一个中意的去检出即可<br><img src="/.com//../../img/9.png" alt="header"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> checkout -b android-msm-bonito-<span class="hljs-number">4</span>.<span class="hljs-number">9</span>-android10  origin/android-msm-bonito-<span class="hljs-number">4</span>.<span class="hljs-number">9</span>-android10<br><br></code></pre></td></tr></table></figure><p>下载完毕<br><img src="/.com//../../img/10.png" alt="header"><br>接下来就是编译一下内核看看有没有问题了<br>因为编译内核有一大堆命令就搞个sh脚本来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#吧之前编译的内核清理掉 在msm下面操作啊 别再aosp 要不然直接清空了</span><br>make clean<br><span class="hljs-comment"># 设置编译平台为64位arm</span><br>export ARCH=arm64<br>export SUBARCH=arm64<br><span class="hljs-comment"># 配置arm64的交叉编译工具路径</span><br>export PATH=<span class="hljs-regexp">/home/</span>用户名<span class="hljs-regexp">/bin/</span>aosp1000r2<span class="hljs-regexp">/prebuilts/g</span>cc<span class="hljs-regexp">/linux-x86/</span>aarch64<span class="hljs-regexp">/aarch64-linux-android-4.9/</span>bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 配置arm32的交叉编译工具路径</span><br>export PATH=<span class="hljs-regexp">/home/</span>用户名<span class="hljs-regexp">/bin/</span>aosp1000r2<span class="hljs-regexp">/prebuilts/g</span>cc<span class="hljs-regexp">/linux-x86/</span>arm<span class="hljs-regexp">/arm-linux-androideabi-4.9/</span>bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 设置64位交叉编译工具前缀，上述64位工具路径中的公共前缀，以CROSS_COMPILEgcc为准</span><br>export CROSS_COMPILE=aarch64-linux-android-<br><span class="hljs-comment"># 设置32位交叉编译工具前缀，上述32位工具路径中的公共前缀，以CROSS_COMPILEgcc为准</span><br>export CROSS_COMPILE_ARM32=arm-linux-androideabi-<br><span class="hljs-comment"># 生成编译配置文件，O=out指定输出目录</span><br>make O=out marlin_defconfig<br><span class="hljs-comment"># 执行内核编译  根据自己设置的cup核心</span><br>make -j18 O=out ARCH=arm64<br><span class="hljs-comment"># 复制内核到marlin-kernel目录</span><br>cp -f out<span class="hljs-regexp">/arch/</span>arm64<span class="hljs-regexp">/boot/</span>Image.lz4-dtb ..<span class="hljs-regexp">/device/g</span>oogle<span class="hljs-regexp">/marlin-kernel/</span>;<br></code></pre></td></tr></table></figure><p>写好sh脚本后 改一下给个777权限 运行就好了</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">chmod 777 tutu.<span class="hljs-keyword">sh</span><br>./tutu.<span class="hljs-keyword">sh</span><br><span class="hljs-comment">//然后直接在aops目录 编译完成后刷机即可</span><br>make -j16<br></code></pre></td></tr></table></figure><p>接下来就是修改内核源码了<br><img src="/.com//../../img/11.png" alt="header"><br>可以看到这些函数实际上真正底层是在内核实现的<br><img src="/.com//../../img/12.png" alt="header"><br>这里只搞一个做演示哈 这里是oepn内核的源码 我们可以在这里动一些手脚</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long <span class="hljs-keyword">do</span><span class="hljs-constructor">_sys_open(<span class="hljs-params">int</span> <span class="hljs-params">dfd</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-params">__user</span> <span class="hljs-operator">*</span><span class="hljs-params">filename</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>, <span class="hljs-params">umode_t</span> <span class="hljs-params">mode</span>)</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> open_flags op;<br>    <span class="hljs-built_in">int</span> fd = build<span class="hljs-constructor">_open_flags(<span class="hljs-params">flags</span>, <span class="hljs-params">mode</span>, &amp;<span class="hljs-params">op</span>)</span>;<br>    <span class="hljs-keyword">struct</span> filename *tmp;<br><br>    <span class="hljs-comment">//add</span><br>    const <span class="hljs-keyword">struct</span> cred *cred = current<span class="hljs-constructor">_cred()</span>;<br>    kuid_t isuid = cred-&gt;uid;<br>    <span class="hljs-built_in">int</span> pid = current-&gt;pid;<br>    <span class="hljs-built_in">int</span> isuid = uid.<span class="hljs-keyword">val</span>;<br>    <span class="hljs-comment">//过滤系统app</span><br>    <span class="hljs-keyword">if</span>(isuid &gt; <span class="hljs-number">10000</span>) &#123;<br>        <span class="hljs-built_in">char</span> bufname<span class="hljs-literal">[<span class="hljs-number">256</span>]</span>=&#123;<span class="hljs-number">0</span>&#125;;<br>        strncpy<span class="hljs-constructor">_from_user(<span class="hljs-params">bufname</span>, <span class="hljs-params">filename</span>, 255)</span>;<br><span class="hljs-comment">/*bufname 就是监控到的一些调用syscall的一些读文件操作当然也可以做io重定向去判断某些特定的值写一个系统app去监听这里过滤替换的一些操作这里为了简单学习实现先这样了*/</span><br>        printk(<span class="hljs-string">&quot;do_sys_open : %s  uid:%d pid:%d\n&quot;</span>, <br>        bufname, isuid, pid);<br>    &#125;<br>    <span class="hljs-comment">//add end</span><br><br><br>    <span class="hljs-keyword">if</span> (fd)<br>        return fd;<br><br>    tmp = getname(filename);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-constructor">IS_ERR(<span class="hljs-params">tmp</span>)</span>)<br>        return <span class="hljs-constructor">PTR_ERR(<span class="hljs-params">tmp</span>)</span>;<br>    <span class="hljs-comment">//得到一个文件描述符</span><br>    fd = get<span class="hljs-constructor">_unused_fd_flags(<span class="hljs-params">flags</span>)</span>;<br>    <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//得到一个struct file结构</span><br>        <span class="hljs-keyword">struct</span> file *f = <span class="hljs-keyword">do</span><span class="hljs-constructor">_filp_open(<span class="hljs-params">dfd</span>, <span class="hljs-params">tmp</span>, &amp;<span class="hljs-params">op</span>)</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">IS_ERR(<span class="hljs-params">f</span>)</span>) &#123;<br>            put<span class="hljs-constructor">_unused_fd(<span class="hljs-params">fd</span>)</span>;<br>            fd = <span class="hljs-constructor">PTR_ERR(<span class="hljs-params">f</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fsnotify<span class="hljs-constructor">_open(<span class="hljs-params">f</span>)</span>;<br>            <span class="hljs-comment">//把文件描述符和struct file结构关联起来</span><br>            fd<span class="hljs-constructor">_install(<span class="hljs-params">fd</span>, <span class="hljs-params">f</span>)</span>;<br>        &#125;<br>    &#125;<br>    putname(tmp);<br>    return fd;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改完毕后直接使用之前写的sh脚本在msm编译内核即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./tutu.sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
