

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="听说你是小兔叽">
  <meta name="keywords" content="">
  
    <meta name="description" content="安卓系统编译前置知识aosp源码、对应的Linux内核、对应的手机驱动这里的对应指的是要跟aosp系统版本对应，要与手机型号对应推荐电脑配置 硬盘1t以上 内存 32g以上 android10 源码编译的下载1. 源码下载北方用清华镜像源    https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;help&#x2F;AOSP&#x2F;南方用中科大镜像源    http:&#x2F;&#x2F;mirrors.us">
<meta property="og:type" content="article">
<meta property="og:title" content="记录编译aosp+修改源码">
<meta property="og:url" content="http://example.com/2022/02/15/%E7%BC%96%E8%AF%91aosp-%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E5%AE%9A%E5%88%B6%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD/index.html">
<meta property="og:site_name" content="听说你是小兔叽的博客">
<meta property="og:description" content="安卓系统编译前置知识aosp源码、对应的Linux内核、对应的手机驱动这里的对应指的是要跟aosp系统版本对应，要与手机型号对应推荐电脑配置 硬盘1t以上 内存 32g以上 android10 源码编译的下载1. 源码下载北方用清华镜像源    https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;help&#x2F;AOSP&#x2F;南方用中科大镜像源    http:&#x2F;&#x2F;mirrors.us">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-15T06:31:38.000Z">
<meta property="article:modified_time" content="2022-11-17T12:44:01.080Z">
<meta property="article:author" content="听说你是小兔叽">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>记录编译aosp+修改源码 - 听说你是小兔叽的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>听说你是小兔叽 个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="记录编译aosp+修改源码"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-15 14:31" pubdate>
          2022年2月15日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          49k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          406 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">记录编译aosp+修改源码</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="安卓系统编译前置知识"><a href="#安卓系统编译前置知识" class="headerlink" title="安卓系统编译前置知识"></a>安卓系统编译前置知识</h1><p>aosp源码、对应的Linux内核、对应的手机驱动<br>这里的对应指的是要跟aosp系统版本对应，要与手机型号对应<br>推荐电脑配置 硬盘1t以上 内存 32g以上</p>
<h1 id="android10-源码编译的下载"><a href="#android10-源码编译的下载" class="headerlink" title="android10 源码编译的下载"></a>android10 源码编译的下载</h1><h2 id="1-源码下载"><a href="#1-源码下载" class="headerlink" title="1. 源码下载"></a>1. 源码下载</h2><p>北方用清华镜像源<br>    <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a><br>南方用中科大镜像源<br>    <a target="_blank" rel="noopener" href="http://mirrors.ustc.edu.cn/help/aosp.html">http://mirrors.ustc.edu.cn/help/aosp.html</a></p>
<h2 id="3-下载初始化包并解压"><a href="#3-下载初始化包并解压" class="headerlink" title="3. 下载初始化包并解压"></a>3. 下载初始化包并解压</h2><p>mkdir ~&#x2F;bin<br>cd ~&#x2F;bin</p>
<p>wget <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-20220222.tar">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-20220222.tar</a><br>    wget可以使用-c选项，来支持断点下载<br>md5sum aosp-latest.tar<br>tar xvf aosp-latest.tar</p>
<h2 id="4-配置git"><a href="#4-配置git" class="headerlink" title="4. 配置git"></a>4. 配置git</h2><p>sudo apt-get install git<br>git config –global user.email <a href="mailto:&#x32;&#x34;&#x33;&#53;&#x38;&#x37;&#53;&#55;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;">&#x32;&#x34;&#x33;&#53;&#x38;&#x37;&#53;&#55;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;</a><br>git config –global user.name “tuzi”</p>
<h2 id="5-下载repo"><a href="#5-下载repo" class="headerlink" title="5. 下载repo"></a>5. 下载repo</h2><p>echo “PATH&#x3D;~&#x2F;bin:$PATH” &gt;&gt; ~&#x2F;.bashrc<br>source ~&#x2F;.bashrc<br>sudo apt-get install curl<br>curl -sSL  ‘<a target="_blank" rel="noopener" href="https://gerrit-googlesource.proxy.ustclug.org/git-repo/+/master/repo?format=TEXT&#39;">https://gerrit-googlesource.proxy.ustclug.org/git-repo/+/master/repo?format=TEXT&#39;</a> |base64 -d &gt; ~&#x2F;bin&#x2F;repo<br>chmod a+x ~&#x2F;bin&#x2F;repo<br>export REPO_URL&#x3D;’<a target="_blank" rel="noopener" href="https://gerrit-googlesource.proxy.ustclug.org/git-repo&#39;">https://gerrit-googlesource.proxy.ustclug.org/git-repo&#39;</a><br>cd aosp</p>
<h2 id="6-修改默认Python"><a href="#6-修改默认Python" class="headerlink" title="6. 修改默认Python"></a>6. 修改默认Python</h2><p>sudo unlink &#x2F;usr&#x2F;bin&#x2F;python<br>sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.8 &#x2F;usr&#x2F;bin&#x2F;python</p>
<h2 id="7-同步指定版本源码"><a href="#7-同步指定版本源码" class="headerlink" title="7. 同步指定版本源码"></a>7. 同步指定版本源码</h2><p>repo init -u git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;aosp&#x2F;platform&#x2F;manifest -b android-10.0.0_r11<br>repo sync</p>
<p>（a) 代号和细分版本号可查看以下链接<br>    <a target="_blank" rel="noopener" href="https://source.android.com/setup/start/build-numbers?hl=zh_cn">https://source.android.com/setup/start/build-numbers?hl=zh_cn</a></p>
<p>（b) 选个有驱动的，支持机型多的分支</p>
<p>（c) 谷歌手机设备驱动下载地址<br><a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a></p>
<p>（d)同步之前先打个虚拟机快照</p>
<p>repo sync的时候有可能会遇到的问题<br>info: A new version of repo is available<br>repo: Updating release signing keys to keyset ver 2.3<br>warning: repo is not tracking a remote branch, so it will not receive updates<br>repo reset: error: Entry ‘.github&#x2F;workflows&#x2F;test-ci.yml’ not uptodate. Cannot merge.<br>fatal: 不能重置索引文件至版本 ‘v2.16^0’。</p>
<p>解决方案：<br>cd ~&#x2F;bin&#x2F;aosp&#x2F;.repo&#x2F;repo<br>git pull<br>cd ~&#x2F;bin&#x2F;aosp<br>再次repo init 和 repo sync</p>
<h1 id="android10源码的编译"><a href="#android10源码的编译" class="headerlink" title="android10源码的编译"></a>android10源码的编译</h1><h2 id="1、安装JDK8"><a href="#1、安装JDK8" class="headerlink" title="1、安装JDK8"></a>1、安装JDK8</h2><p>sudo add-apt-repository ppa:openjdk-r&#x2F;ppa<br>sudo apt-get update<br>sudo apt-get install openjdk-8-jdk</p>
<h2 id="2、安装所需依赖-Ubuntu-20-04"><a href="#2、安装所需依赖-Ubuntu-20-04" class="headerlink" title="2、安装所需依赖 (Ubuntu 20.04)"></a>2、安装所需依赖 (Ubuntu 20.04)</h2><p>sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig libncurses5<br>参考以下地址<br>    <a target="_blank" rel="noopener" href="https://source.android.com/setup/build/initializing?hl=zh-cn">https://source.android.com/setup/build/initializing?hl=zh-cn</a></p>
<h2 id="3、设备驱动的准备"><a href="#3、设备驱动的准备" class="headerlink" title="3、设备驱动的准备"></a>3、设备驱动的准备</h2><p>谷歌手机设备驱动下载地址<br><a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a></p>
<h2 id="4、查看内核是否存在"><a href="#4、查看内核是否存在" class="headerlink" title="4、查看内核是否存在"></a>4、查看内核是否存在</h2><p>源码下载完后最好看下里面有没有你手机对应的设备内核<br>如果没有，需要另外下载或者编译<br><a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/build/building-kernels#id-version">https://source.android.google.cn/setup/build/building-kernels#id-version</a></p>
<h2 id="5、编译源码"><a href="#5、编译源码" class="headerlink" title="5、编译源码"></a>5、编译源码</h2><p>编译参考以下链接<br><a target="_blank" rel="noopener" href="https://source.android.com/setup/build/building">https://source.android.com/setup/build/building</a><br>make clobber<br>source build&#x2F;envsetup.sh<br>lunch	# 选择设备内核和编译版本<br>        # 增加编译产品选项 修改aosp&#x2F;device&#x2F;google&#x2F;marlin&#x2F;AndroidProducts.mk<br>        -j 是cpu 选择适合自己的<br>make -j24</p>
<p>bonito 为手机代号<br>编译成功后编译生成的文件在home&#x2F;tuzi&#x2F;bin&#x2F;aosp&#x2F;out&#x2F;target&#x2F;product&#x2F;bonito<br>对应管方刷机包里的img文件 都拖进去即可</p>
<h2 id="编译补充"><a href="#编译补充" class="headerlink" title="编译补充"></a>编译补充</h2><ol>
<li><p>编译报错或者修改系统文件以后，都可以直接make，已经编译的部分会跳过</p>
</li>
<li><p>make clean 会清除已经编译的，全部重来，在编译不同lunch选项时使用</p>
</li>
<li><p>单独编译system.img，在根目录下<br>source build&#x2F;envsetup.sh<br>lunch xxx<br>make systemimage -j4</p>
</li>
<li><p>单独编译某个模块 mmm packages&#x2F;apps&#x2F;tuzi<br>将单独编译的模块打包到img镜像中 make snod</p>
</li>
</ol>
<h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb reboot bootloader<br>fastboot  flash  boot  boot.img<br>fastboot  flash  recovery  recovery.img<br>fastboot  flash  system  system.img<br>fastboot  flash  bootloader  bootloader.img<br>fastboot boot &lt;recovery_filename&gt;.img<br></code></pre></td></tr></table></figure>

<h1 id="AOSP源码导入到AndroidStudio"><a href="#AOSP源码导入到AndroidStudio" class="headerlink" title="AOSP源码导入到AndroidStudio"></a>AOSP源码导入到AndroidStudio</h1><ol>
<li><p>先成功编译一次，再使用以下方法导入</p>
</li>
<li><p>在ubuntu系统下，进入源码根目录，运行如下命令, 会在源码目录下的out&#x2F;host&#x2F;linux-x86&#x2F;framework目录下生成了idegen.jar文件<br>source build&#x2F;envsetup.sh<br>mmm development&#x2F;tools&#x2F;idegen&#x2F;</p>
</li>
<li><p>在源码根目录下继续执行如下命令，会在根目录下生成android.iml和android.ipr两个文件，这两个文件是AndroidStudio的工程配置文件<br>development&#x2F;tools&#x2F;idegen&#x2F;idegen.sh</p>
</li>
<li><p>安装并打开AndroidStudio，选择Open an existing Android Studio project，找到源码根目录，点击Android.ipr</p>
</li>
</ol>
<h1 id="Frida持久化介绍"><a href="#Frida持久化介绍" class="headerlink" title="Frida持久化介绍"></a>Frida持久化介绍</h1><ol>
<li><p>Hook的前提<br>需要将代码或者能够完成Hook功能的东西，注入到目标进程中<br>安卓中注入的方式：zygote注入、ptrace注入、文件感染等</p>
</li>
<li><p>frida-server<br>利用ptrace注入，需要root权限<br>为了方便Hook代码修改，还设计成了需要与PC端连接</p>
</li>
<li><p>frida-gadget<br>当Hook代码修改测试完毕，可以通过它来实现免root、脱离PC<br>但是它本身没有注入功能，需要将其打包到app中</p>
</li>
<li><p>魔改系统<br>在app启动过程中，自动加载frida-gadget，就可以不用修改app了，更通用</p>
</li>
</ol>
<h2 id="frida持久化的几种方案"><a href="#frida持久化的几种方案" class="headerlink" title="frida持久化的几种方案"></a>frida持久化的几种方案</h2><p>1.Android平台感染ELF文件实现模块注入 </p>
<p>2.修改smali，调用System.loadLibrary来加载so</p>
<p>上面两种方法都有成品<a target="_blank" rel="noopener" href="https://github.com/nszdhd1/UtilScript">https://github.com/nszdhd1/UtilScript</a><br>使用方式见<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-268175.htm">https://bbs.pediy.com/thread-268175.htm</a><br>3.修改rom 在app启动过程中加载frida-gadget</p>
<h2 id="修改app启动流程"><a href="#修改app启动流程" class="headerlink" title="修改app启动流程"></a>修改app启动流程</h2><h3 id="1-打开app时判断是否启用持久化"><a href="#1-打开app时判断是否启用持久化" class="headerlink" title="1. 打开app时判断是否启用持久化"></a>1. 打开app时判断是否启用持久化</h3><p>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java<br>在以上文件中，添加代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">// add<br>        String curPkgName = data.appInfo.packageName;<br>        int curUid = Process.myUid();<br>        <span class="hljs-keyword">if</span> (curUid &gt; 10000) &#123;<br>            Persist.LOGD(<span class="hljs-string">&quot;curPkgName: &quot;</span> + curPkgName + <span class="hljs-string">&quot; curUid: &quot;</span> + curUid);<br>            Boolean isPersist = Persist.isEnablePersist(curPkgName);<br>            Persist.LOGD(<span class="hljs-string">&quot;isPersist: &quot;</span> + isPersist);<br>            <span class="hljs-keyword">if</span> (isPersist) &#123;<br>                <span class="hljs-keyword">if</span>(Persist.dotuzi(appContext, curPkgName))&#123;<br>                    Persist.LOGD(<span class="hljs-string">&quot;dotuzi is ok&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    Persist.LOGD(<span class="hljs-string">&quot;dotuzi failed&quot;</span>);<br>                &#125;;<br>            &#125;<br>        &#125;<br>// add<br></code></pre></td></tr></table></figure>

<h3 id="2-增加自定义包和类"><a href="#2-增加自定义包和类" class="headerlink" title="2. 增加自定义包和类"></a>2. 增加自定义包和类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs bash">package com.tuzi;<br><br>import android.content.Context;<br>import android.util.Log;<br>import android.os.Process;<br><br>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br><br>import org.json.JSONObject;<br><br><br>public class Persist &#123;<br><br>    public static final String SO_NAME = <span class="hljs-string">&quot;libtuzi.so&quot;</span>;<br>    public static final String SO_CONFIG_NAME = <span class="hljs-string">&quot;libtuzi.config.so&quot;</span>;<br>    public static final String LIB32_DIR = <span class="hljs-string">&quot;/system/lib&quot;</span>;<br>    public static final String LIB64_DIR = <span class="hljs-string">&quot;/system/lib64&quot;</span>;<br><br>    public static final String SETTINGS_DIR = <span class="hljs-string">&quot;/data/system/xsettings/tuzi/persist&quot;</span>;<br>    public static final String ENABLE_PERSIST_FILE_NAME = <span class="hljs-string">&quot;tuzi_persist&quot;</span>;<br><br>    public static final String CONFIG_JS_DIR = <span class="hljs-string">&quot;/data/system/xsettings/tuzi/jscfg&quot;</span>;<br>    public static final String CONFIG_JS_FILE_NAME = <span class="hljs-string">&quot;config.js&quot;</span>;<br><br>    public static final String TAG_NAME = <span class="hljs-string">&quot;tuzi_persist&quot;</span>;<br><br><br>    public static void LOGD(String msg) &#123;<br>        Log.d(TAG_NAME, msg);<br>    &#125;<br><br>    private static boolean saveFile(String filePath, String textMsg) &#123;<br>        try&#123;<br>            FileOutputStream fileOutputStream = new FileOutputStream(filePath);<br>            fileOutputStream.write(textMsg.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>));<br>            fileOutputStream.flush();<br>            fileOutputStream.close();<br>            <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    private static boolean copyFile(File srcFile, File dstFile) &#123;<br>        try&#123;<br>            FileInputStream fileInputStream = new FileInputStream(srcFile);<br>            FileOutputStream fileOutputStream = new FileOutputStream(dstFile);<br>            byte[] data = new byte[16 * 1024];<br>            int len = -1;<br>            <span class="hljs-keyword">while</span>((len = fileInputStream.<span class="hljs-built_in">read</span>(data)) != -1) &#123;<br>                fileOutputStream.write(data,0, len);<br>                fileOutputStream.flush();<br>            &#125;<br>            fileInputStream.close();<br>            fileOutputStream.close();<br>            <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    // 判断app是否打开自动注入脚本功能<br>    public static boolean isEnablePersist(String pkgName) &#123;<br>        // 判断文件是否存在 /data/system/xsettings/tuzi/persist/com.tuzi.app/tuzi_persist<br>        File enableFile = new File(SETTINGS_DIR, pkgName + File.separator + ENABLE_PERSIST_FILE_NAME);<br>        <span class="hljs-built_in">return</span> enableFile.exists();<br>    &#125;<br>    // 获取源JS文件路径<br>    private static File getConfigJSPath(String pkgName) &#123;<br>        // /data/system/xsettings/tuzi/jscfg/com.tuzi.app/config.js<br>        <span class="hljs-built_in">return</span> new File(CONFIG_JS_DIR, pkgName + File.separator + CONFIG_JS_FILE_NAME);<br>    &#125;<br>    // 拷贝源JS文件到app私有目录<br>    private static File copyJSFile(Context context, String pkgName) &#123;<br>        // 判断源JS文件是否存在<br>        File srcJSFile = getConfigJSPath(pkgName);<br>        <span class="hljs-keyword">if</span>(!srcJSFile.exists()) &#123;<br>            LOGD(<span class="hljs-string">&quot;srcJSFile not exists&quot;</span>);<br>            <span class="hljs-built_in">return</span> null;<br>        &#125;<br>        // 拷贝源JS文件到app私有目录<br>        // /data/data/com.tuzi.app/files/config.js<br>        File dstJSFile = new File(context.getFilesDir(), CONFIG_JS_FILE_NAME);<br>        boolean isCopyJSOk = copyFile(srcJSFile, dstJSFile);<br>        <span class="hljs-keyword">if</span>(!isCopyJSOk)&#123;<br>            LOGD(<span class="hljs-string">&quot;copyJSFile fail: &quot;</span> + srcJSFile + <span class="hljs-string">&quot; -&gt; &quot;</span> + dstJSFile);<br>            <span class="hljs-built_in">return</span> null;<br>        &#125;<br>        <span class="hljs-built_in">return</span> dstJSFile;<br>    &#125;<br>    // 生成Gadget配置文件<br>    private static boolean genGadgetConfig(Context context, File dstJSFile) &#123;<br>        JSONObject jsonObject = new JSONObject();<br>        JSONObject childObj = new JSONObject();<br>        try &#123;<br>            childObj.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;script&quot;</span>);<br>            childObj.put(<span class="hljs-string">&quot;path&quot;</span>, dstJSFile.toString());<br>            jsonObject.put(<span class="hljs-string">&quot;interaction&quot;</span>, childObj);<br>        &#125;catch (Exception e)&#123;<br>            e.printStackTrace();<br><span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        String configFilePath = context.getFilesDir() + File.separator + SO_CONFIG_NAME;<br>        boolean isSaveOk = saveFile(configFilePath, jsonObject.toString());<br>        <span class="hljs-keyword">if</span>(!isSaveOk)&#123;<br>            LOGD(<span class="hljs-string">&quot;saveFile fail: &quot;</span> + configFilePath);<br>            <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    // 拷贝源so文件到app私有目录<br>    private static File copySoFile(Context context) &#123;<br>        // 判断源so文件是否存在<br>        // /system/lib/libtuzi.so<br>        // /system/lib64/libtuzi.so<br>        File srcSoFile = new File(LIB32_DIR, SO_NAME);<br>        <span class="hljs-keyword">if</span>(Process.is64Bit()) &#123;<br>            srcSoFile = new File(LIB64_DIR, SO_NAME);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!srcSoFile.exists()) &#123;<br>            LOGD(<span class="hljs-string">&quot;srcSoFile not exists&quot;</span>);<br>            <span class="hljs-built_in">return</span> null;<br>        &#125;<br>        // 拷贝源so文件到app私有目录<br>        // /data/data/com.tuzi.app/files/libtuzi.so<br>        File dstSoFile = new File(context.getFilesDir(), SO_NAME);<br>        <span class="hljs-keyword">if</span>(srcSoFile.length() != dstSoFile.length()) &#123;<br>            boolean isCopyFileOk = copyFile(srcSoFile, dstSoFile);<br>            <span class="hljs-keyword">if</span>(!isCopyFileOk)&#123;<br>                LOGD(<span class="hljs-string">&quot;copySoFile fail: &quot;</span> + srcSoFile + <span class="hljs-string">&quot; -&gt; &quot;</span> + dstSoFile);<br>                <span class="hljs-built_in">return</span> null;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">return</span> dstSoFile;<br>    &#125;<br>    // 进行Frida Gadget持久化<br>    public static boolean dotuziPersist(Context context, String pkgName) &#123;<br>        File dstJSFile = copyJSFile(context, pkgName);<br>        <span class="hljs-keyword">if</span>(null == dstJSFile) <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(!genGadgetConfig(context, dstJSFile)) <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>        File dstSoFile = copySoFile(context);<br>        <span class="hljs-keyword">if</span>(null == dstSoFile) <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>        System.load(dstSoFile.toString());<br>        <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="3-将自定义包加入白名单"><a href="#3-将自定义包加入白名单" class="headerlink" title="3. 将自定义包加入白名单"></a>3. 将自定义包加入白名单</h3><p>&#x2F;build&#x2F;make&#x2F;core&#x2F;tasks&#x2F;check_boot_jars&#x2F;package_whitelist.txt</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br>com\.tuzi<br><span class="hljs-comment"># // add</span><br></code></pre></td></tr></table></figure>

<h3 id="4-frida-gadget集成到系统"><a href="#4-frida-gadget集成到系统" class="headerlink" title="4. frida-gadget集成到系统"></a>4. frida-gadget集成到系统</h3><p>将 frida-gadget 放到源码目录，比如如下文件夹中<br>&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;libtuzi</p>
<p>修改源码以下文件，将 frida-gadget 拷贝到编译以后的系统中<br>&#x2F;build&#x2F;make&#x2F;target&#x2F;product&#x2F;handheld_system.mk</p>
<p>添加以下数据，自动拷贝文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br>PRODUCT_COPY_FILES += \<br>    frameworks/base/cmds/tuzi/frida-gadget-14.2.18-android-arm.so:$(TARGET_COPY_OUT_SYSTEM)/lib/libtuzi.so \<br>    frameworks/base/cmds/tuzi/frida-gadget-14.2.18-android-arm64.so:$(TARGET_COPY_OUT_SYSTEM)/lib64/libtuzi.so<br><span class="hljs-comment"># // add</span><br></code></pre></td></tr></table></figure>

<h3 id="5-自定义目录设计"><a href="#5-自定义目录设计" class="headerlink" title="5. 自定义目录设计"></a>5. 自定义目录设计</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/data/system/xsettings/tuzi/persist/pkgName/tuzi_persist<br>/data/system/xsettings/tuzi/jscfg/pkgName/config.js<br>persist_tuzi文件存在，则表示开启持久化<br>config.js表示用于注入的hook代码<br></code></pre></td></tr></table></figure>

<h3 id="6-开机创建自定义目录"><a href="#6-开机创建自定义目录" class="headerlink" title="6. 开机创建自定义目录"></a>6. 开机创建自定义目录</h3><p>&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc 文件中添加以下数据 625</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br><span class="hljs-comment"># /data/system/xsettings/tuzi/persist</span><br><span class="hljs-built_in">mkdir</span> /data/system/xsettings 0775 system system<br><span class="hljs-built_in">mkdir</span> /data/system/xsettings/tuzi 0775 system system<br><span class="hljs-built_in">mkdir</span> /data/system/xsettings/tuzi/persist 0775 system system<br><span class="hljs-built_in">mkdir</span> /data/system/xsettings/tuzi/jscfg 0775 system system<br><span class="hljs-comment"># // add</span><br></code></pre></td></tr></table></figure>

<h3 id="7-创建文件类型SeLinux标签：tuzi-file"><a href="#7-创建文件类型SeLinux标签：tuzi-file" class="headerlink" title="7. 创建文件类型SeLinux标签：tuzi_file"></a>7. 创建文件类型SeLinux标签：tuzi_file</h3><p>7.1 在如下文件中添加数据<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/system/sepolicy/public/file.te<br>/system/sepolicy/prebuilts/api/29.0/public/file.te<br></code></pre></td></tr></table></figure><br>7.2 在以上文件中添加如下数据，两个文件添加的内容需要一致 405</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br><span class="hljs-comment"># /data/system/xsettings/tuzi/persist</span><br><span class="hljs-built_in">type</span> tuzi_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;<br><span class="hljs-comment"># // add</span><br><br></code></pre></td></tr></table></figure>
<p>7.3 注意文件不要以注释结尾，每行结束加分号</p>
<h3 id="8-为自定义目录关联文件类型标签-tuzi-file"><a href="#8-为自定义目录关联文件类型标签-tuzi-file" class="headerlink" title="8. 为自定义目录关联文件类型标签: tuzi_file"></a>8. 为自定义目录关联文件类型标签: tuzi_file</h3><p>8.1 在如下文件中添加数据</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/</span>file_contexts<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span>/file_contexts<br></code></pre></td></tr></table></figure>
<p>8.2 在以上文件中添加如下数据，两个文件添加的内容需要一致 122<br>  注意文件不要以注释结尾<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br><span class="hljs-comment"># /data/system/xsettings/tuzi/persist</span><br>/data/system/xsettings(/.*)?	u:object_r:tuzi_file:s0<br><span class="hljs-comment"># // add</span><br></code></pre></td></tr></table></figure></p>
<h3 id="9-配置system-app访问-tuzi-file-标签文件的权限"><a href="#9-配置system-app访问-tuzi-file-标签文件的权限" class="headerlink" title="9. 配置system app访问 tuzi_file 标签文件的权限"></a>9. 配置system app访问 tuzi_file 标签文件的权限</h3><p>9.1 在如下文件中添加数据</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/</span>system_app.te<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span>/system_app.te<br></code></pre></td></tr></table></figure>
<p>9.2 在以上文件中添加如下数据，两个文件添加的内容需要一致 末尾</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br><span class="hljs-comment"># add for accessing tuzi_file</span><br>allow system_app tuzi_file:<span class="hljs-built_in">dir</span>  &#123; getattr setattr open <span class="hljs-built_in">read</span> write remove_name create add_name search <span class="hljs-built_in">rmdir</span> &#125;;<br>allow system_app tuzi_file:file &#123; getattr setattr open <span class="hljs-built_in">read</span> write create <span class="hljs-built_in">unlink</span> &#125;;<br></code></pre></td></tr></table></figure>
<h3 id="10-配置第三方app访问-tuzi-file-标签文件的权限"><a href="#10-配置第三方app访问-tuzi-file-标签文件的权限" class="headerlink" title="10. 配置第三方app访问 tuzi_file 标签文件的权限"></a>10. 配置第三方app访问 tuzi_file 标签文件的权限</h3><p>10.1 在如下文件中添加数据</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/u</span>ntrusted_app.te<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/u</span>ntrusted_app_25.te<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/u</span>ntrusted_app_27.te<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/u</span>ntrusted_app_all.te<br><br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span>/untrusted_app.te<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span>/untrusted_app_25.te<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span>/untrusted_app_27.te<br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span>/untrusted_app_all.te<br></code></pre></td></tr></table></figure>
<p>10.2 在以上文件中添加如下数据，两个文件添加的内容需要一致 末尾</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br><span class="hljs-comment"># add for accessing tuzi_file</span><br>allow untrusted_app tuzi_file:<span class="hljs-built_in">dir</span>  &#123; getattr open <span class="hljs-built_in">read</span> write search <span class="hljs-built_in">rmdir</span> &#125;;<br>allow untrusted_app tuzi_file:file &#123; getattr open <span class="hljs-built_in">read</span> write &#125;;<br></code></pre></td></tr></table></figure>

<h2 id="安卓编译常见错误"><a href="#安卓编译常见错误" class="headerlink" title="安卓编译常见错误"></a>安卓编译常见错误</h2><h3 id="11-文件-system-x2F-sepolicy-x2F-prebuilts-x2F-api-x2F-29-0-x2F-private-x2F-untrusted-app-all-te-和-system-x2F-sepolicy-x2F-private-x2F-untrusted-app-all-te-不同"><a href="#11-文件-system-x2F-sepolicy-x2F-prebuilts-x2F-api-x2F-29-0-x2F-private-x2F-untrusted-app-all-te-和-system-x2F-sepolicy-x2F-private-x2F-untrusted-app-all-te-不同" class="headerlink" title="11. 文件 system&#x2F;sepolicy&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;private&#x2F;untrusted_app_all.te 和 system&#x2F;sepolicy&#x2F;private&#x2F;untrusted_app_all.te 不同"></a>11. 文件 system&#x2F;sepolicy&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;private&#x2F;untrusted_app_all.te 和 system&#x2F;sepolicy&#x2F;private&#x2F;untrusted_app_all.te 不同</h3><h3 id="12-修改以下文件，防止报错：tuzi-file-未定义"><a href="#12-修改以下文件，防止报错：tuzi-file-未定义" class="headerlink" title="12. 修改以下文件，防止报错：tuzi_file 未定义"></a>12. 修改以下文件，防止报错：tuzi_file 未定义</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/</span>compat<span class="hljs-regexp">/26.0/</span><span class="hljs-number">26.0</span>.ignore.cil <span class="hljs-number">17</span><br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/</span>compat<span class="hljs-regexp">/27.0/</span><span class="hljs-number">27.0</span>.ignore.cil <span class="hljs-number">16</span><br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/private/</span>compat<span class="hljs-regexp">/28.0/</span><span class="hljs-number">28.0</span>.ignore.cil <span class="hljs-number">15</span><br><br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span><span class="hljs-regexp">/compat/</span><span class="hljs-number">26.0</span>/<span class="hljs-number">26.0</span>.ignore.cil <span class="hljs-number">17</span><br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span><span class="hljs-regexp">/compat/</span><span class="hljs-number">27.0</span>/<span class="hljs-number">27.0</span>.ignore.cil <span class="hljs-number">16</span><br><span class="hljs-regexp">/system/</span>sepolicy<span class="hljs-regexp">/prebuilts/</span>api<span class="hljs-regexp">/29.0/</span><span class="hljs-keyword">private</span><span class="hljs-regexp">/compat/</span><span class="hljs-number">28.0</span>/<span class="hljs-number">28.0</span>.ignore.cil <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>
<p>在以上文件中加入数据 tuzi_file<br>两个文件添加的内容需要一致</p>
<h3 id="13-You-have-tried-to-change-the-API-from-what-has-been-previously-released-inan-SDK-Please-fix-the-errors-listed-above"><a href="#13-You-have-tried-to-change-the-API-from-what-has-been-previously-released-inan-SDK-Please-fix-the-errors-listed-above" class="headerlink" title="13. You have tried to change the API from what has been previously released inan SDK. Please fix the errors listed above"></a>13. You have tried to change the API from what has been previously released inan SDK. Please fix the errors listed above</h3><p>修改了代码以后，有些时候需要先 make update-api，再编译</p>
<h2 id="Frida持久化管理app的开发"><a href="#Frida持久化管理app的开发" class="headerlink" title="Frida持久化管理app的开发"></a>Frida持久化管理app的开发</h2><h3 id="1-管理app的功能"><a href="#1-管理app的功能" class="headerlink" title="1. 管理app的功能"></a>1. 管理app的功能</h3><pre><code class="hljs">显示已安装app列表
可以对每个app指定需要注入的JS
可以设置是否启用持久化
</code></pre>
<h3 id="2-相应功能实现原理"><a href="#2-相应功能实现原理" class="headerlink" title="2. 相应功能实现原理"></a>2. 相应功能实现原理</h3><pre><code class="hljs">3.1 创建表示启用的文件
/data/system/xsettings/tuzi/persist/pkgName/tuzi_persist
3.2 指定的JS文件复制到以下目录
/data/system/xsettings/tuzi/jscfg/pkgName/config.js
3.3 剩下的复制so、JS文件和加载so的操作，由魔改的dotuziPersist函数完成
</code></pre>
<h2 id="system权限的app开发"><a href="#system权限的app开发" class="headerlink" title="system权限的app开发"></a>system权限的app开发</h2><h3 id="1-system权限app的开发"><a href="#1-system权限app的开发" class="headerlink" title="1. system权限app的开发"></a>1. system权限app的开发</h3><p>1.1 在 manifest 中加入 android:sharedUserId&#x3D;”android.uid.system”<br>1.2 将编译出来的app放入 &#x2F;packages&#x2F;apps&#x2F;tuziPersist<br>1.3 编写Android.mk，也放入该文件夹<br>1.4 单独编译指定模块 mmm packages&#x2F;apps&#x2F;tuziPersist<br>1.5 编译后的模块在 &#x2F;out&#x2F;target&#x2F;product&#x2F;sailfish&#x2F;system&#x2F;app&#x2F;ControlAPP<br>1.6 使用 make snod 将编译出来的文件打包成镜像，刷入system.img即可</p>
<h3 id="2-如果要在编译整个系统时，一起编译这个模块，需要将模块-ControlAPP-加入源码编译链"><a href="#2-如果要在编译整个系统时，一起编译这个模块，需要将模块-ControlAPP-加入源码编译链" class="headerlink" title="2. 如果要在编译整个系统时，一起编译这个模块，需要将模块 ControlAPP 加入源码编译链"></a>2. 如果要在编译整个系统时，一起编译这个模块，需要将模块 ControlAPP 加入源码编译链</h3><p>2.1 增加的内置模块，如果为APP，加入到如下文件中</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/build/m</span>ake<span class="hljs-regexp">/target/</span>product/handheld_product.mk<br></code></pre></td></tr></table></figure>
<p>2.2 增加的内置模块，如果为可执行程序，加入到如下文件中</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/build/m</span>ake<span class="hljs-regexp">/target/</span>product/base_system.mk<br></code></pre></td></tr></table></figure>
<h2 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># // add</span><br><span class="hljs-comment"># 设置当前工作路径</span><br>LOCAL_PATH:= $(call my-dir)<br><br><br><span class="hljs-comment"># 清除变量值</span><br>include $(CLEAR_VARS)<br><span class="hljs-comment"># 生成的模块名称</span><br>LOCAL_MODULE := ControlAPP<br><br><br><span class="hljs-comment"># 生成的模块类型</span><br>LOCAL_MODULE_CLASS := APPS<br><span class="hljs-comment"># 生成的模块后缀名,此处为apk</span><br>LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)<br><span class="hljs-comment"># 设置模块tag，tags取值可以为:user debug eng tests optional</span><br><span class="hljs-comment"># optional表示全平台编译</span><br>LOCAL_MODULE_TAGS := optional<br><br><span class="hljs-comment"># LOCAL_PRIVILEGED_MODULE := true</span><br><br>LOCAL_BUILT_MODULE_STEM := package.apk<br><br>LOCAL_DEX_PREOPT := <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 设置源文件</span><br>LOCAL_SRC_FILES := $(LOCAL_MODULE).apk<br><br>LOCAL_CERTIFICATE := platform<br><br><span class="hljs-comment"># 设置签名，此处表示保持apk原有签名</span><br><span class="hljs-comment"># LOCAL_CERTIFICATE := PRESIGNED</span><br><span class="hljs-comment"># 此处表示预编译方式</span><br>include $(BUILD_PREBUILT)<br><br></code></pre></td></tr></table></figure>
<h1 id="加固与脱壳介绍"><a href="#加固与脱壳介绍" class="headerlink" title="加固与脱壳介绍"></a>加固与脱壳介绍</h1><h3 id="1-什么是加固"><a href="#1-什么是加固" class="headerlink" title="1. 什么是加固"></a>1. 什么是加固</h3><p>演示加固前后的反编译结果<br>其实就是将原先app的dex文件加密，app运行过程中，解密后再加载<br>反编译时看到的就是壳的代码，或者被抽空的代码</p>
<h3 id="2-什么是脱壳"><a href="#2-什么是脱壳" class="headerlink" title="2. 什么是脱壳"></a>2. 什么是脱壳</h3><pre><code class="hljs">演示脱壳前后的反编译结果
本质上就是将加固app运行过程中，解密后加载的dex文件保存下来
与加密算法差不多，一个加密的是字符/字节数据，一个加密的是文件(也是字节数据)
</code></pre>
<p>逆向加密算法主要要的是过程，做算法还原，而脱壳要的是解密后的dex文件</p>
<h3 id="3-为什么要脱壳"><a href="#3-为什么要脱壳" class="headerlink" title="3. 为什么要脱壳"></a>3. 为什么要脱壳</h3><p>不脱壳反编译时，通常只能看到壳的代码，或者被抽取后的代码<br>360：整体加固以及被vmp化的onCreate<br>ijiami：函数体指令被抽取，用nop填充原有数据，或者干脆就变成空函数</p>
<h3 id="4-分析加固的app是不是必须脱壳？"><a href="#4-分析加固的app是不是必须脱壳？" class="headerlink" title="4. 分析加固的app是不是必须脱壳？"></a>4. 分析加固的app是不是必须脱壳？</h3><p>比如可以直接trace指令 但是静态分析配合动态分析才是优选</p>
<h3 id="5-怎么判断app是否加固"><a href="#5-怎么判断app是否加固" class="headerlink" title="5. 怎么判断app是否加固"></a>5. 怎么判断app是否加固</h3><p>反编译查看类数量、类中的方法特征<br>反编译查看类名特征、so特征 libjiagu.so、qihoo<br>查壳工具<br>没有加固的，也可以脱壳</p>
<h3 id="6-加固的分类"><a href="#6-加固的分类" class="headerlink" title="6. 加固的分类"></a>6. 加固的分类</h3><p>dex加固：整体加固、抽取加固、VMP、dex2c等<br>so加固：对so结构进行处理、对so数据进行加密、自定义linker<br>一般处理方式就是so dump，然后so修复</p>
<h2 id="整体加固介绍"><a href="#整体加固介绍" class="headerlink" title="整体加固介绍"></a>整体加固介绍</h2><h3 id="1-整体加固"><a href="#1-整体加固" class="headerlink" title="1. 整体加固"></a>1. 整体加固</h3><p>1.1 可分为落地加载、内存加载<br>1.2 本质上都是将app自身的dex整体加密，app运行过程中解密后加载<br>1.3 有些壳还会抹掉dex文件头、dex的文件大小filesize等<br>1.4 一般会有字符串加密、资源加密、反调试、签名验证</p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><p>2.1 脱壳工具fdex2<br>通过Class类的getDex方法得到DexFile，再通过DexFile的getBytes方法得到dex文件<br>2.2 脱壳工具blackdex<br>通过mCookie来脱壳<br>2.3 脱壳工具FRIDA-DEXDump<br>从内存中搜索dex文件，保存下来<br>2.4 脱壳系统FART、youpk<br>在dex加载、解析、解释执行过程中，找一个合适的时机，得到DexFile内存地址和大小，将解密状态的dex保存下来<br>还可以通过artMethod来得到DexFile</p>
<h2 id="ART下的脱壳原理"><a href="#ART下的脱壳原理" class="headerlink" title="ART下的脱壳原理"></a>ART下的脱壳原理</h2><h3 id="1-在线源码查看"><a href="#1-在线源码查看" class="headerlink" title="1. 在线源码查看"></a>1. 在线源码查看</h3><p><a target="_blank" rel="noopener" href="http://androidxref.com/">http://androidxref.com/</a><br><a target="_blank" rel="noopener" href="http://aospxref.com/">http://aospxref.com/</a><br><a target="_blank" rel="noopener" href="https://android-opengrok.bangnimang.net/">https://android-opengrok.bangnimang.net/</a><br><a target="_blank" rel="noopener" href="https://cs.android.com/">https://cs.android.com/</a> 需要科学上网</p>
<h3 id="2-ART下的脱壳点"><a href="#2-ART下的脱壳点" class="headerlink" title="2. ART下的脱壳点"></a>2. ART下的脱壳点</h3><p>2.1 dex的加载流程</p>
<p>通过mCookie脱壳的</p>
<p>通过openCommen函数脱壳的</p>
<p>通过DexFile构造函数脱壳的</p>
<p>youpk：通过ClassLinker的DexCacheData进一步得到DexFile</p>
<p>2.2 dex2oat的编译流程</p>
<p>通过修改dex2oat脱壳的</p>
<p>2.3 类的加载、链接、校验、初始化流程</p>
<p>DexHunter在defineClass进行类解析</p>
<p>LoadMethod、LinkCode</p>
<p>2.4 函数执行过程中的脱壳点</p>
<p>FART: Execute整体脱壳</p>
<p>FART：ArtMethod::invoke函数中进行dump CodeItem</p>
<p>youpk：直接到了解释执行的函数中进行dump CodeItem</p>
<h3 id="3-InMemoryDexClassLoader源码分析"><a href="#3-InMemoryDexClassLoader源码分析" class="headerlink" title="3. InMemoryDexClassLoader源码分析"></a>3. InMemoryDexClassLoader源码分析</h3><p>早期脱壳点：openCommen、DexFile</p>
<p>整体脱壳的本质：就是找到DexFile对象</p>
<h3 id="4-mCookie脱壳原理"><a href="#4-mCookie脱壳原理" class="headerlink" title="4. mCookie脱壳原理"></a>4. mCookie脱壳原理</h3><p>ConvertJavaArrayToDexFiles<br>ConvertDexFilesToJavaArray</p>
<h3 id="5-DexClassLoader源码分析"><a href="#5-DexClassLoader源码分析" class="headerlink" title="5. DexClassLoader源码分析"></a>5. DexClassLoader源码分析</h3><p>Android 10 不再从应用进程调用dex2oat<br><a target="_blank" rel="noopener" href="https://developer.android.com/about/versions/10/behavior-changes-10?hl=zh-cn#system-only-oat">https://developer.android.com/about/versions/10/behavior-changes-10?hl=zh-cn#system-only-oat</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/YZcoder/article/details/120648821">https://blog.csdn.net/YZcoder/article/details/120648821</a><br>早期脱壳点：OpenAndReadMagic、openCommen、DexFile</p>
<h3 id="6-youpk脱壳原理"><a href="#6-youpk脱壳原理" class="headerlink" title="6. youpk脱壳原理"></a>6. youpk脱壳原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">std::list&lt;const DexFile*&gt; Unpacker::<span class="hljs-function"><span class="hljs-title">getDexFiles</span></span>() &#123;<br>  std::list&lt;const DexFile*&gt; dex_files;<br>  Thread* const self = Thread::Current();<br>  ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();<br>  ReaderMutexLock mu(self, *class_linker-&gt;DexLock());<br>  const std::list&lt;ClassLinker::DexCacheData&gt;&amp; dex_caches = class_linker-&gt;GetDexCachesData();<br>  <span class="hljs-keyword">for</span> (auto it = dex_caches.begin(); it != dex_caches.end(); ++it) &#123;<br>    ClassLinker::DexCacheData data = *it;<br>    const DexFile* dex_file = data.dex_file;<br>    const std::string&amp; dex_location = dex_file-&gt;GetLocation();<br>    <span class="hljs-keyword">if</span> (dex_location.rfind(<span class="hljs-string">&quot;/system/&quot;</span>, 0) == 0) &#123;<br>      <span class="hljs-built_in">continue</span>;<br>    &#125;<br>    dex_files.push_back(dex_file);<br>  &#125;<br>  <span class="hljs-built_in">return</span> dex_files;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="fartExt"><a href="#fartExt" class="headerlink" title="fartExt"></a>fartExt</h3><h4 id="解决抽取壳在脱壳完成后还需要手动修复"><a href="#解决抽取壳在脱壳完成后还需要手动修复" class="headerlink" title="解决抽取壳在脱壳完成后还需要手动修复"></a>解决抽取壳在脱壳完成后还需要手动修复</h4><p>​ 在优化这个问题前，首先要意识到为什么会需要手动修复，当我们理解了大佬的处理之后，就发现hanbingle大佬为了避免每个函数主动调用都将dex给保存，所以只有文件不存在的时候才保存。也就意味着我们保存的dex是第一个主动调用执行时的dex。如果这个抽取壳是必须函数执行后才会恢复的，那么后面的函数在这个保存dex中都依然是被抽取的。FART的做法是将codeitem保存出来后，然后再修复。所以我将这里优化了一下。</p>
<p>​ 知道问题所在后，优化的思路就清晰了，我采用了比较简单的一种优化方式，就是每个dex文件保存时，将这个dex的地址以及长度给保存下来。最后在所有主动调用完成时，重新将所有dex文件再保存一次。下面看看优化后的相关代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>//存放dex的指针和长度<br>static std::map&lt;void*,size_t&gt; dex_map;<br> <br>//主动调用函数的dump处理<br>extern <span class="hljs-string">&quot;C&quot;</span> void dumpArtMethod(ArtMethod* artmethod)  REQUIRES_SHARED(Locks::mutator_lock_) &#123;<br>                ...<br>                int dexfilefp=open(dexfilepath,O_RDONLY,0666);<br>                ///dex文件存在则不处理,避免主动调用每次都要重新保存dex<br>                <span class="hljs-keyword">if</span>(dexfilefp&gt;0)&#123;<br>                    close(dexfilefp);<br>                    dexfilefp=0;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;mikrom ArtMethod::dumpdexfilebyArtMethod save dex_map&quot;</span>;<br>                    //将这个地址给保存下来<br>                    dex_map.insert(std::pair&lt;void*,size_t&gt;((void*)begin_,size_));<br>                    int fp=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);<br>                    ...<br>                &#125;<br>&#125;<br>//主动调用完成时,重新保存到文件名&lt;dexSize&gt;_dexfile_repair.dex中<br>extern <span class="hljs-string">&quot;C&quot;</span> void dumpDexOver()  REQUIRES_SHARED(Locks::mutator_lock_) &#123;<br>    <span class="hljs-keyword">if</span>(dex_map.size()&lt;=0)&#123;<br>            LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;mikrom dumpDexOver dex_map.size()&lt;=0&quot;</span>;<br>        <span class="hljs-built_in">return</span>;<br>    &#125;<br>    char *dexfilepath=(char*)malloc(sizeof(char)*1000);<br>    LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;mikrom ArtMethod::dumpDexOver&quot;</span>;<br>    int result=0;<br>    char* packageName=ArtMethod::GetPackageName();<br>    std::map&lt;void*, size_t&gt;::iterator iter;<br>    <span class="hljs-keyword">for</span>(iter = dex_map.begin(); iter != dex_map.end(); iter++) &#123;<br>        void* begin_=iter-&gt;first;<br>        size_t size_=iter-&gt;second;<br>        int size_int_=(int)size_;<br>        memset(dexfilepath,0,1000);<br>        sprintf(dexfilepath,<span class="hljs-string">&quot;/sdcard/Android/data/%s/files/dump&quot;</span>,packageName);<br>        <span class="hljs-built_in">mkdir</span>(dexfilepath,0777);<br>        memset(dexfilepath,0,1000);<br>        sprintf(dexfilepath,<span class="hljs-string">&quot;/sdcard/Android/data/%s/files/dump/%d_dexfile_repair.dex&quot;</span>,packageName,size_int_);<br>        int dexfilefp=open(dexfilepath,O_RDONLY,0666);<br>        <span class="hljs-keyword">if</span>(dexfilefp&gt;0)&#123;<br>          close(dexfilefp);<br>          dexfilefp=0;<br> <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          int fp=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);<br>          <span class="hljs-keyword">if</span>(fp&gt;0)<br>          &#123;<br>              result=write(fp,(void*)begin_,size_);<br>              <span class="hljs-keyword">if</span>(result&lt;0)<br>              &#123;<br>                  LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;mikrom ArtMethod::dumpDexOver,open dexfilepath error&quot;</span>;<br>              &#125;<br>              fsync(fp);<br>              close(fp);<br>              memset(dexfilepath,0,1000);<br>          &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dexfilepath!=nullptr)<br>    &#123;<br>        free(dexfilepath);<br>        dexfilepath=nullptr;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="7-dex2oat的脱壳原理"><a href="#7-dex2oat的脱壳原理" class="headerlink" title="7. dex2oat的脱壳原理"></a>7. dex2oat的脱壳原理</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7af31cc5130e">https://www.jianshu.com/p/7af31cc5130e</a></p>
<h3 id="8-fdex2脱壳原理-classObj-getDex-getBytes"><a href="#8-fdex2脱壳原理-classObj-getDex-getBytes" class="headerlink" title="8. fdex2脱壳原理 classObj.getDex().getBytes()"></a>8. fdex2脱壳原理 classObj.getDex().getBytes()</h3><h3 id="9-FART：Execute"><a href="#9-FART：Execute" class="headerlink" title="9. FART：Execute"></a>9. FART：Execute</h3><h3 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h3><p>只要能够获取到DexFile的地方，都可以尝试脱壳<br>也可以是间接得到DexFile的地方，比如ArtMathod-&gt;getDexFile()</p>
<h3 id="11-常见脱壳点"><a href="#11-常见脱壳点" class="headerlink" title="11. 常见脱壳点"></a>11. 常见脱壳点</h3><p>函数解释执行Execute<br>通过ClassLinker的DexCacheData进一步得到DexFile<br>内存搜索dex文件来dump<br>通过mCookie脱壳的</p>
<p>通过DexFile构造函数脱壳的<br>LoadMethod传入的DexFile<br>LinkCode传入的ArtMethod进一步得到DexFile, ArtMethod-&gt;getDexFile() </p>
<h2 id="AOSP源码导入到Clion"><a href="#AOSP源码导入到Clion" class="headerlink" title="AOSP源码导入到Clion"></a>AOSP源码导入到Clion</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. Clion的安装<br><br>2. 生成用于将源码导入Clion的CMakeLists.txt<br>// 打开开关，编译时生成CMakeLists.txt<br><span class="hljs-built_in">export</span> SOONG_GEN_CMAKEFILES=1<br><span class="hljs-built_in">export</span> SOONG_GEN_CMAKEFILES_DEBUG=1<br><br>// 全编译<br>make -j24<br><br>// CMakeLists.txt会生成在<br>out/development/ide/clion/art/runtime/libart-arm64-android/CMakeLists.txt<br><br>3. 用Clion打开该CMakeLists.txt<br><br>4. tools --&gt; cmake --&gt; Change Project Root<br>选择aosp源码根路径，等解析完毕即可<br></code></pre></td></tr></table></figure>

<h1 id="打造自己的脱壳系统"><a href="#打造自己的脱壳系统" class="headerlink" title="打造自己的脱壳系统"></a>打造自己的脱壳系统</h1><h3 id="1-FART源码分析"><a href="#1-FART源码分析" class="headerlink" title="1. FART源码分析"></a>1. FART源码分析</h3><h3 id="2-FART迁移至安卓10"><a href="#2-FART迁移至安卓10" class="headerlink" title="2. FART迁移至安卓10"></a>2. FART迁移至安卓10</h3><h3 id="3-Linux-C语言中的open函数"><a href="#3-Linux-C语言中的open函数" class="headerlink" title="3. Linux C语言中的open函数"></a>3. Linux C语言中的open函数</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39296438/article/details/79422068">https://blog.csdn.net/weixin_39296438/article/details/79422068</a></p>
<h3 id="4-Linux-C语言判断文件是否存在"><a href="#4-Linux-C语言判断文件是否存在" class="headerlink" title="4. Linux C语言判断文件是否存在"></a>4. Linux C语言判断文件是否存在</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kunkliu/article/details/108294089">https://blog.csdn.net/kunkliu/article/details/108294089</a></p>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><p>5.1 改源码时，多加输出和快照，方便排错和快速还原到上一个状态<br>5.2 移植代码时，关注一些安卓特有的类、对象、方法是否改变，比如fdex2的脱壳函数在8.0之后就没有了</p>
<h2 id="抽取加固介绍"><a href="#抽取加固介绍" class="headerlink" title="抽取加固介绍"></a>抽取加固介绍</h2><h3 id="1-抽取加固本质：提取出dex中方法体的字节码，并在方法运行时还原"><a href="#1-抽取加固本质：提取出dex中方法体的字节码，并在方法运行时还原" class="headerlink" title="1. 抽取加固本质：提取出dex中方法体的字节码，并在方法运行时还原"></a>1. 抽取加固本质：提取出dex中方法体的字节码，并在方法运行时还原</h3><h3 id="2-抽取加固的实现形式"><a href="#2-抽取加固的实现形式" class="headerlink" title="2. 抽取加固的实现形式"></a>2. 抽取加固的实现形式</h3><p>抽空方法体代码，运行方法后回填，运行完后不再抽取 –&gt; 延时保存<br>抽空方法体代码，运行方法后回填，运行完后又抽取 –&gt; FART、youpk主动调用<br>抽空方法体代码，将原有函数体替换为解密代码，运行时解密执行</p>
<h3 id="3-抽取加固对原有dex的处理形式"><a href="#3-抽取加固对原有dex的处理形式" class="headerlink" title="3. 抽取加固对原有dex的处理形式"></a>3. 抽取加固对原有dex的处理形式</h3><p>原有函数体数据空间置0，保留原有空间<br>对dex文件进行重构，不保留原有空间，在还原数据时，修改CodeItemOffest</p>
<h2 id="抽取加固解决方案"><a href="#抽取加固解决方案" class="headerlink" title="抽取加固解决方案"></a>抽取加固解决方案</h2><h3 id="1-解决思路：在函数运行时，保存被抽取的数据"><a href="#1-解决思路：在函数运行时，保存被抽取的数据" class="headerlink" title="1. 解决思路：在函数运行时，保存被抽取的数据"></a>1. 解决思路：在函数运行时，保存被抽取的数据</h3><h4 id="fart"><a href="#fart" class="headerlink" title="fart"></a>fart</h4><p>FART的主动调用的深度是在函数的主动执行过程中  这样的深度肯定是不够的 有些壳必须在函数执行了之后，才会还原出真实的函数。FART的主动调用深度。函数真正执行前就已经被直接结束掉了。所以需要更深的主动调用才能够解决这种抽取壳。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,<br>                       const char* shorty) &#123;<br>    //判断传入是self是否为空为空就是fart主动调用组件<br>    <span class="hljs-keyword">if</span> (self== nullptr) &#123;<br>        dumpArtMethod(this);<br>        <span class="hljs-built_in">return</span>;<br>    &#125;<br>      ...<br> &#125;<br></code></pre></td></tr></table></figure>
<h4 id="youpk"><a href="#youpk" class="headerlink" title="youpk"></a>youpk</h4><p>Youpk更深的主动调用判断如果这个函数的第一个指令是goto，就正常执行，然后执行到invoke-static的指令。这个指令完成之后就直接结束掉函数调用。避免真实函数调用会出现异常。</p>
<p>参考Youpk的看看他是如何实现更深的主动调用来解决这个问题的。下面是第一步，先修改默认的解释器为Switch的解释器。这是因为Switch解释器的可读性更加高，方便我们直接修改源码来达到目的。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static constexpr InterpreterImplKind kInterpreterImplKind <span class="hljs-operator">=</span> kSwitchImplKind<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>看看主动调用时Youpk是怎么模拟参数的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">void Unpacker::<span class="hljs-function"><span class="hljs-title">invokeAllMethods</span></span>() &#123;<br>          ...<br>      auto methods = klass-&gt;GetDeclaredMethods(pointer_size);<br>      Unpacker::enableFakeInvoke();<br>      <span class="hljs-keyword">for</span> (auto&amp; m : methods) &#123;<br>        ArtMethod* method = &amp;m;<br>        <span class="hljs-keyword">if</span> (!method-&gt;IsProxyMethod() &amp;&amp; method-&gt;IsInvokable()) &#123;<br>          //获取参数个数<br>          uint32_t args_size = (uint32_t)ArtMethod::NumArgRegisters(method-&gt;GetShorty());<br>          <span class="hljs-keyword">if</span> (!method-&gt;IsStatic()) &#123;<br>            args_size += 1;<br>          &#125;<br>          //模拟参数<br>          JValue result;<br>          std::vector&lt;uint32_t&gt; args(args_size, 0);<br>          <span class="hljs-keyword">if</span> (!method-&gt;IsStatic()) &#123;<br>            mirror::Object* thiz = klass-&gt;AllocObject(self);<br>            args[0] = StackReference&lt;mirror::Object&gt;::FromMirrorPtr(thiz).AsVRegValue(); <br>          &#125;<br>          method-&gt;Invoke(self, args.data(), args_size, &amp;result, method-&gt;GetShorty());<br>        &#125;<br>      &#125;<br>      Unpacker::disableFakeInvoke();<br>      cJSON_ReplaceItemInObject(current, <span class="hljs-string">&quot;status&quot;</span>, cJSON_CreateString(<span class="hljs-string">&quot;Dumped&quot;</span>));<br>      writeJson();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里可以看到Youpk的参数是模拟赋值进去的。而寒冰大佬的做法不大一样。看看FART的函数调用模拟。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">extern <span class="hljs-string">&quot;C&quot;</span> void myfartInvoke(ArtMethod* artmethod)  REQUIRES_SHARED(Locks::mutator_lock_) &#123;<br>    JValue *result=nullptr;<br>    Thread *self=nullptr;<br>    uint32_t temp=6;<br>    uint32_t* args=&amp;temp;<br>    uint32_t args_size=6;<br>    artmethod-&gt;Invoke(self, args, args_size, result, <span class="hljs-string">&quot;fart&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样肯定没法顺利往后执行。我们先继续参考Youpk的后续。<br>然后看看Youpk的ArtMethod::Invoke的处理，如果是主动调用并且非Native函数就正常执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,<br>                       const char* shorty) &#123;<br>  ...<br>  //patch by Youlor<br>  //++++++++++++++++++++++++++++<br>  //如果是主动调用fake invoke并且不是native方法则强制走解释器<br>  <span class="hljs-keyword">if</span> (UNLIKELY(!runtime-&gt;IsStarted() || Dbg::IsForcedInterpreterNeededForCalling(self, this)<br>      || (Unpacker::isFakeInvoke(self, this) &amp;&amp; !this-&gt;IsNative()))) &#123;<br>  //++++++++++++++++++++++++++++<br>    <span class="hljs-keyword">if</span> (IsStatic()) &#123;<br>      art::interpreter::EnterInterpreterFromInvoke(<br>          self, this, nullptr, args, result, /*stay_in_interpreter*/ <span class="hljs-literal">true</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      mirror::Object* receiver =<br>          reinterpret_cast&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[0])-&gt;AsMirrorPtr();<br>      art::interpreter::EnterInterpreterFromInvoke(<br>          self, this, receiver, args + 1, result, /*stay_in_interpreter*/ <span class="hljs-literal">true</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    //patch by Youlor<br>    //++++++++++++++++++++++++++++<br>    //如果是主动调用fake invoke并且是native方法则不执行<br>    <span class="hljs-keyword">if</span> (Unpacker::isFakeInvoke(self, this) &amp;&amp; this-&gt;IsNative()) &#123;<br>      // Pop transition.<br>      self-&gt;PopManagedStackFragment(fragment);<br>      <span class="hljs-built_in">return</span>;<br>    &#125;<br>    //++++++++++++++++++++++++++++<br>    ...<br>  &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来看解释器的EnterInterpreterFromInvoke函数处理。这里Youpk没有什么处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">void EnterInterpreterFromInvoke(Thread* self, ArtMethod* method, Object* receiver,<br>                                uint32_t* args, JValue* result,<br>                                bool stay_in_interpreter) &#123;<br>         ...<br>    JValue r = Execute(self, code_item, *shadow_frame, JValue(), stay_in_interpreter);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看函数Execute。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bahs">static inline JValue Execute(<br>    Thread* self,<br>    const DexFile::CodeItem* code_item,<br>    ShadowFrame&amp; shadow_frame,<br>    JValue result_register,<br>    bool stay_in_interpreter = false) SHARED_REQUIRES(Locks::mutator_lock_) &#123;<br>      ...<br>    &#125; else if (kInterpreterImplKind == kSwitchImplKind) &#123;<br>      if (transaction_active) &#123;<br>        return ExecuteSwitchImpl&lt;false, true&gt;(self, code_item, shadow_frame, result_register,<br>                                              false);<br>      &#125; else &#123;<br>        return ExecuteSwitchImpl&lt;false, false&gt;(self, code_item, shadow_frame, result_register,<br>                                               false);<br>      &#125;<br>    &#125;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后这ExecuteSwitchImpl就是关键的解释指令的函数了。到这里有Youpk修改的部分了。先看看修改的代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">//++++++++++++++++++++++++++++<br><span class="hljs-comment">#define PREAMBLE()                                                                              \</span><br>  <span class="hljs-keyword">do</span> &#123;                                                                                          \<br>    inst_count++;                                                                               \<br>    bool dumped = Unpacker::beforeInstructionExecute(self, shadow_frame.GetMethod(),            \<br>                                                     dex_pc, inst_count);                       \<br>    <span class="hljs-keyword">if</span> (dumped) &#123;                                                                               \<br>      <span class="hljs-built_in">return</span> JValue();                                                                          \<br>    &#125;                                                                                           \<br>    <span class="hljs-keyword">if</span> (UNLIKELY(instrumentation-&gt;HasDexPcListeners())) &#123;                                       \<br>      instrumentation-&gt;DexPcMovedEvent(self, shadow_frame.GetThisObject(code_item-&gt;ins_size_),  \<br>                                       shadow_frame.GetMethod(), dex_pc);                       \<br>    &#125;                                                                                           \<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>)<br>//++++++++++++++++++++++++++++<br>//patch by Youlor<br></code></pre></td></tr></table></figure>

<p>PREAMBLE这个函数基本每个指令执行前都会调用beforeInstructionExecute来判断下。如果这里dump脱壳了，就直接结束掉，这个函数不再往下执行了。如果是上面那种特殊壳，这里就可以暂时先不要dump。让他正常执行先。下面看看里面的逻辑处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs bash">//继续解释执行返回<span class="hljs-literal">false</span>, dump完成返回<span class="hljs-literal">true</span><br>bool Unpacker::beforeInstructionExecute(Thread *self, ArtMethod *method, uint32_t dex_pc, int inst_count) &#123;<br>  <span class="hljs-keyword">if</span> (Unpacker::isFakeInvoke(self, method)) &#123;<br>    const uint16_t* const insns = method-&gt;GetCodeItem()-&gt;insns_;<br>    const Instruction* inst = Instruction::At(insns + dex_pc);<br>    uint16_t inst_data = inst-&gt;Fetch16(0);<br>    Instruction::Code opcode = inst-&gt;Opcode(inst_data);<br> <br>    //对于一般的方法抽取(非ijiami, najia), 直接在第一条指令处dump即可<br>    <span class="hljs-keyword">if</span> (inst_count == 0 &amp;&amp; opcode != Instruction::GOTO &amp;&amp; opcode != Instruction::GOTO_16 &amp;&amp; opcode != Instruction::GOTO_32) &#123;<br>      Unpacker::dumpMethod(method);<br>      <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    //ijiami, najia的特征为: goto: goto_decrypt; nop; ... ; <span class="hljs-built_in">return</span>; const vx, n; invoke-static xxx; goto: goto_origin;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inst_count == 0 &amp;&amp; opcode &gt;= Instruction::GOTO &amp;&amp; opcode &lt;= Instruction::GOTO_32) &#123;<br>      <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inst_count == 1 &amp;&amp; opcode &gt;= Instruction::CONST_4 &amp;&amp; opcode &lt;= Instruction::CONST_WIDE_HIGH16) &#123;<br>      <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inst_count == 2 &amp;&amp; (opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE)) &#123;<br>      //让这条指令真正的执行<br>      Unpacker::disableFakeInvoke();<br>      Unpacker::enableRealInvoke();<br>      <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inst_count == 3) &#123;<br>      <span class="hljs-keyword">if</span> (opcode &gt;= Instruction::GOTO &amp;&amp; opcode &lt;= Instruction::GOTO_32) &#123;<br>        //写入时将第一条GOTO用nop填充<br>        const Instruction* inst_first = Instruction::At(insns);<br>        Instruction::Code first_opcode = inst_first-&gt;Opcode(inst-&gt;Fetch16(0));<br>        CHECK(first_opcode &gt;= Instruction::GOTO &amp;&amp; first_opcode &lt;= Instruction::GOTO_32);<br>        ULOGD(<span class="hljs-string">&quot;found najia/ijiami %s&quot;</span>, PrettyMethod(method).c_str());<br>        switch (first_opcode)<br>        &#123;<br>        <span class="hljs-keyword">case</span> Instruction::GOTO:<br>          Unpacker::dumpMethod(method, 2);<br>          <span class="hljs-built_in">break</span>;<br>        <span class="hljs-keyword">case</span> Instruction::GOTO_16:<br>          Unpacker::dumpMethod(method, 4);<br>          <span class="hljs-built_in">break</span>;<br>        <span class="hljs-keyword">case</span> Instruction::GOTO_32:<br>          Unpacker::dumpMethod(method, 8);<br>          <span class="hljs-built_in">break</span>;<br>        default:<br>          <span class="hljs-built_in">break</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Unpacker::dumpMethod(method);<br>      &#125;<br>      <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    Unpacker::dumpMethod(method);<br>    <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里可以看到。如果是INVOKE_STATIC就让指令正常执行。其他正常的抽取壳的深度就是在这里。这相当于就是指令执行前进行dump了。但是这里依然没解决特殊壳的深度问题。必须执行完INVOKE_STATIC之后。再进行脱壳并结束掉函数。继续看Youpk下面的处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs bash">template&lt;bool do_access_check, bool transaction_active&gt;<br>JValue ExecuteSwitchImpl(Thread* self, const DexFile::CodeItem* code_item,<br>                         ShadowFrame&amp; shadow_frame, JValue result_register,<br>                         bool interpret_one_instruction) &#123;<br>  ...<br>  //patch by Youlor<br>  //++++++++++++++++++++++++++++<br>  int inst_count = -1;<br>  //++++++++++++++++++++++++++++<br>  <span class="hljs-keyword">do</span> &#123;<br>    dex_pc = inst-&gt;GetDexPc(insns);<br>    shadow_frame.SetDexPC(dex_pc);<br>    TraceExecution(shadow_frame, inst, dex_pc);<br>    inst_data = inst-&gt;Fetch16(0);<br>    switch (inst-&gt;Opcode(inst_data)) &#123;<br>      ...<br>      <span class="hljs-keyword">case</span> Instruction::GOTO: &#123;<br>        PREAMBLE();<br>        int8_t offset = inst-&gt;VRegA_10t(inst_data);<br>        BRANCH_INSTRUMENTATION(offset);<br>        <span class="hljs-keyword">if</span> (IsBackwardBranch(offset)) &#123;<br>          HOTNESS_UPDATE();<br>          self-&gt;AllowThreadSuspension();<br>        &#125;<br>        inst = inst-&gt;RelativeAt(offset);<br>        <span class="hljs-built_in">break</span>;<br>      &#125;<br>      ...<br>      <span class="hljs-keyword">case</span> Instruction::INVOKE_STATIC: &#123;<br>        PREAMBLE();<br>        bool success = DoInvoke&lt;kStatic, <span class="hljs-literal">false</span>, do_access_check&gt;(<br>            self, shadow_frame, inst, inst_data, &amp;result_register);<br>        POSSIBLY_HANDLE_PENDING_EXCEPTION(!success, Next_3xx);<br>        <span class="hljs-built_in">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> Instruction::INVOKE_STATIC_RANGE: &#123;<br>        PREAMBLE();<br>        bool success = DoInvoke&lt;kStatic, <span class="hljs-literal">true</span>, do_access_check&gt;(<br>            self, shadow_frame, inst, inst_data, &amp;result_register);<br>        POSSIBLY_HANDLE_PENDING_EXCEPTION(!success, Next_3xx);<br>        <span class="hljs-built_in">break</span>;<br>      &#125;<br>      ...<br>    &#125;<br>    //patch by Youlor<br>    //++++++++++++++++++++++++++++<br>    bool dumped = Unpacker::afterInstructionExecute(self, shadow_frame.GetMethod(), dex_pc, inst_count);<br>    <span class="hljs-keyword">if</span> (dumped) &#123;<br>      <span class="hljs-built_in">return</span> JValue();<br>    &#125;<br>    //++++++++++++++++++++++++++++<br>  &#125; <span class="hljs-keyword">while</span> (!interpret_one_instruction);<br>  // Record <span class="hljs-built_in">where</span> we stopped.<br>  shadow_frame.SetDexPC(inst-&gt;GetDexPc(insns));<br>  <span class="hljs-built_in">return</span> result_register;<br>&#125;  // NOLINT(readability/fn_size)<br></code></pre></td></tr></table></figure>


<p>这里就看到每个指令都执行了PREAMBLE函数。然后每个指令执行完都执行了afterInstructionExecute这个函数。在这里就可以判断，如果执行完的指令是INVOKE_STATIC。就可以直接return结束掉函数执行了。看看Youpk的处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">bool Unpacker::afterInstructionExecute(Thread *self, ArtMethod *method, uint32_t dex_pc, int inst_count) &#123;<br>  const uint16_t* const insns = method-&gt;GetCodeItem()-&gt;insns_;<br>  const Instruction* inst = Instruction::At(insns + dex_pc);<br>  uint16_t inst_data = inst-&gt;Fetch16(0);<br>  Instruction::Code opcode = inst-&gt;Opcode(inst_data);<br>  <span class="hljs-keyword">if</span> (inst_count == 2 &amp;&amp; (opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE)<br>      &amp;&amp; Unpacker::isRealInvoke(self, method)) &#123;<br>    Unpacker::enableFakeInvoke();<br>    Unpacker::disableRealInvoke();<br>  &#125;<br>  <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里留意了一下。这个函数固定返回的false。但是通过设置enableFakeInvoke和disableRealInvoke来控制下一个指令执行的时候来进行退出函数到这里基本就走完大致的流程了。</p>
<h4 id="FartExt更深的主动调用"><a href="#FartExt更深的主动调用" class="headerlink" title="FartExt更深的主动调用"></a>FartExt更深的主动调用</h4><p>和Youpk一样。第一步就是先把解释器给改成使用Switch解释器。但是由于我使用的是AOSP10。所以发现修改部分果然不大一样了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#if ART_USE_CXX_INTERPRETER</span><br>static constexpr InterpreterImplKind kInterpreterImplKind = kSwitchImplKind;<br><span class="hljs-comment">#else</span><br>static constexpr InterpreterImplKind kInterpreterImplKind = kMterpImplKind;<br><span class="hljs-comment">#endif</span><br>发现这里变成可以通过编译参数来控制的了。搜索一下ART_USE_CXX_INTERPRETER的使用<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> envTrue(ctx, <span class="hljs-string">&quot;ART_USE_CXX_INTERPRETER&quot;</span>) &#123;<br>        cflags = append(cflags, <span class="hljs-string">&quot;-DART_USE_CXX_INTERPRETER=1&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>发现这个好像可以通过cflags来配置了。所以我修改了下runtime下的Android.pb。如果不想改全局的。也可以在源码里面直接判断是主动调用就强制走switch解释器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">cflags: [<br>    // ART is allowed to <span class="hljs-built_in">link</span> to libicuuc directly<br>    // since they are <span class="hljs-keyword">in</span> the same module<br>    <span class="hljs-string">&quot;-DANDROID_LINK_SHARED_ICU4C&quot;</span>,<br>    <span class="hljs-string">&quot;-Wno-error&quot;</span>,<br>    <span class="hljs-string">&quot;-DART_USE_CXX_INTERPRETER=1&quot;</span><br>],<br></code></pre></td></tr></table></figure>
<p>接着就是ArtMethod::Invoke的时候不要直接结束了。但是这里我们需要留意的是。第一个参数的Thread是fart用来判断是否为主动调用的。为了让后面能正常执行，我就直接把第一个参数给赋值了。而后面的调用流程也是需要判断当前执行函数是否为主动调用。Youpk是用线程和一个变量来控制判断是否为主动调用的。这里使用result&#x3D;111111在后续判断是否为主动调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash">extern <span class="hljs-string">&quot;C&quot;</span> void fartextInvoke(ArtMethod* artmethod)  REQUIRES_SHARED(Locks::mutator_lock_) &#123;<br>    <span class="hljs-keyword">if</span>(artmethod-&gt;IsNative()||artmethod-&gt;IsAbstract())&#123;<br>        <span class="hljs-built_in">return</span>;<br>    &#125;<br>    JValue result;<br>  //模拟参数<br>    Thread *self=Thread::Current();<br>    uint32_t temp[100]=&#123;0&#125;;<br>    uint32_t* args=temp;<br>    uint32_t args_size = (uint32_t)ArtMethod::NumArgRegisters(artmethod-&gt;GetShorty());<br>    <span class="hljs-keyword">if</span> (!artmethod-&gt;IsStatic()) &#123;<br>      args_size += 1;<br>    &#125;<br>  //靠这个值，在后续来判断当前函数是否为主动调用。<br>    result.SetI(111111);<br>    LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;fartext fartextInvoke&quot;</span>;<br>    Unpacker_self_=self;<br>    artmethod-&gt;Invoke(self, args, args_size, &amp;result,artmethod-&gt;GetShorty());<br>&#125;<br> <br>void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,<br>                       const char* shorty) &#123;<br>  ...<br>  //add<br>  <span class="hljs-keyword">if</span> (result!=nullptr &amp;&amp; result-&gt;GetI()==111111)&#123;<br>      LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;fartext artMethod::Invoke Method &quot;</span>&lt;&lt;<span class="hljs-string">this-&gt;PrettyMethod().c_str();</span><br><span class="hljs-string">      if (IsStatic()) &#123;</span><br><span class="hljs-string">        art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="hljs-string">                        self, this</span>, nullptr, args, result, /*stay_in_interpreter=*/ <span class="hljs-literal">true</span>);<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        //注意这里是把非静态的也当静态的方式处理的。避免使用引用类型参数。<br>        art::interpreter::EnterInterpreterFromInvoke(<br>                  self, this, nullptr, args + 1, result, /*stay_in_interpreter=*/ <span class="hljs-literal">true</span>);<br>      &#125;<br>        LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;fartext artMethod::Invoke Method Over &quot;</span>&lt;&lt;<span class="hljs-string">this-&gt;PrettyMethod().c_str();</span><br><span class="hljs-string">      self-&gt;PopManagedStackFragment(fragment);</span><br><span class="hljs-string">      return;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  //add end</span><br><span class="hljs-string">  ...</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>这里有个问题是上面这种模拟参数的方式，碰到引用类型的参数会报错。所以在处理参数入栈的时候，也要进行判断处理一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs bash">void EnterInterpreterFromInvoke(Thread* self,<br>                                ArtMethod* method,<br>                                ObjPtr&lt;mirror::Object&gt; receiver,<br>                                uint32_t* args,<br>                                JValue* result,<br>                                bool stay_in_interpreter) &#123;<br>  ...<br>  <span class="hljs-keyword">if</span> (!method-&gt;IsStatic()) &#123;<br>    //add  避免使用引用类型的参数<br>    <span class="hljs-keyword">if</span>(result!=nullptr&amp;&amp;result-&gt;GetI()==111111)&#123;<br>        shadow_frame-&gt;SetVReg(cur_reg, args[0]);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        CHECK(receiver != nullptr);<br>        shadow_frame-&gt;SetVRegReference(cur_reg, receiver);<br>    &#125;<br>    //add end<br>    //shadow_frame-&gt;SetVRegReference(cur_reg, receiver);<br>    ++cur_reg;<br>  &#125;<br>  uint32_t shorty_len = 0;<br>  const char* shorty = method-&gt;GetShorty(&amp;shorty_len);<br>  <span class="hljs-keyword">for</span> (size_t shorty_pos = 0, arg_pos = 0; cur_reg &lt; num_regs; ++shorty_pos, ++arg_pos, cur_reg++) &#123;<br>    DCHECK_LT(shorty_pos + 1, shorty_len);<br>    switch (shorty[shorty_pos + 1]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>: &#123;<br>        //add  避免使用引用类型的参数<br>        <span class="hljs-keyword">if</span>(result!=nullptr&amp;&amp;result-&gt;GetI()==111111)&#123;<br>            shadow_frame-&gt;SetVReg(cur_reg, args[0]);<br>            <span class="hljs-built_in">break</span>;<br>        &#125;<br>        //add end<br>        ObjPtr&lt;mirror::Object&gt; o =<br>            reinterpret_cast&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[arg_pos])-&gt;AsMirrorPtr();<br>        shadow_frame-&gt;SetVRegReference(cur_reg, o);<br>        <span class="hljs-built_in">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;J&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>: &#123;<br>        uint64_t wide_value = (static_cast&lt;uint64_t&gt;(args[arg_pos + 1]) &lt;&lt; <span class="hljs-string">32) | args[arg_pos];</span><br><span class="hljs-string">        shadow_frame-&gt;SetVRegLong(cur_reg, wide_value);</span><br><span class="hljs-string">        cur_reg++;</span><br><span class="hljs-string">        arg_pos++;</span><br><span class="hljs-string">        break;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      default:</span><br><span class="hljs-string">        shadow_frame-&gt;SetVReg(cur_reg, args[arg_pos]);</span><br><span class="hljs-string">        break;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  ...</span><br><span class="hljs-string">  if (LIKELY(!method-&gt;IsNative())) &#123;</span><br><span class="hljs-string">    //这里把我们主动调用函数的标志继续往后面传递</span><br><span class="hljs-string">    if(result!=nullptr&amp;&amp;result-&gt;GetI()==111111)&#123;</span><br><span class="hljs-string">        JValue r = Execute(self, accessor, *shadow_frame, *result, stay_in_interpreter);</span><br><span class="hljs-string">        if (result != nullptr) &#123;</span><br><span class="hljs-string">          *result = r;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">          return;</span><br><span class="hljs-string">    &#125;else&#123;</span><br><span class="hljs-string">        JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter);</span><br><span class="hljs-string">        if (result != nullptr) &#123;</span><br><span class="hljs-string">          *result = r;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  ...</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>


<p>接下来就开始修改解释器部分的逻辑了。我们只要做到几点处理。就可以搞定这种壳了。<br>1、如果是主动调用并且第一个指令如果不是GOTO的。就直接脱壳并结束<br>2、如果是主动调用并且第一个指令是GOTO的。让他继续执行<br>3、如果第三个指令是INVOKE-STATIC的执行完后直接结束掉</p>
<p>接下来准备改代码。然后碰到一个问题。同样也是AOSP10的版本导致的。Switch解释器的逻辑发生了较大的变动。先看看变成了啥样子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">template&lt;bool do_access_check, bool transaction_active&gt;<br>ATTRIBUTE_NO_SANITIZE_ADDRESS void ExecuteSwitchImplCpp(SwitchImplContext* ctx) &#123;<br>  ...<br>  bool const interpret_one_instruction = ctx-&gt;interpret_one_instruction;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    dex_pc = inst-&gt;GetDexPc(insns);<br>    shadow_frame.SetDexPC(dex_pc);<br>    TraceExecution(shadow_frame, inst, dex_pc);<br>    inst_data = inst-&gt;Fetch16(0);<br>    &#123;<br>      bool exit_loop = <span class="hljs-literal">false</span>;<br>      InstructionHandler&lt;do_access_check, transaction_active&gt; handler(<br>          ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, exit_loop);<br>      //PREAMBLE变成这种方式调用了<br>      <span class="hljs-keyword">if</span> (!handler.Preamble()) &#123;<br>        <span class="hljs-keyword">if</span> (UNLIKELY(exit_loop)) &#123;<br>          <span class="hljs-built_in">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (UNLIKELY(interpret_one_instruction)) &#123;<br>          <span class="hljs-built_in">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">continue</span>;<br>      &#125;<br>    &#125;<br>    switch (inst-&gt;Opcode(inst_data)) &#123;<br><span class="hljs-comment">#define OPCODE_CASE(OPCODE, OPCODE_NAME, pname, f, i, a, e, v)                                    \</span><br>      <span class="hljs-keyword">case</span> OPCODE: &#123;                                                                              \<br>        bool exit_loop = <span class="hljs-literal">false</span>;                                                                   \<br>        InstructionHandler&lt;do_access_check, transaction_active&gt; handler(                          \<br>            ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, exit_loop);        \<br>        handler.OPCODE_NAME();                                                                    \<br>        /* TODO: Advance <span class="hljs-string">&#x27;inst&#x27;</span> here, instead of explicitly <span class="hljs-keyword">in</span> each handler */                    \<br>        <span class="hljs-keyword">if</span> (UNLIKELY(exit_loop)) &#123;                                                                \<br>          <span class="hljs-built_in">return</span>;                                                                                 \<br>        &#125;                                                                                         \<br>        <span class="hljs-built_in">break</span>;                                                                                    \<br>      &#125;<br>DEX_INSTRUCTION_LIST(OPCODE_CASE)<br><span class="hljs-comment">#undef OPCODE_CASE</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (UNLIKELY(interpret_one_instruction)) &#123;<br>      <span class="hljs-built_in">break</span>;<br>    &#125;<br>  &#125;<br>  // Record <span class="hljs-built_in">where</span> we stopped.<br>  shadow_frame.SetDexPC(inst-&gt;GetDexPc(insns));<br>  ctx-&gt;result = ctx-&gt;result_register;<br>  <span class="hljs-built_in">return</span>;<br>&#125;  // NOLINT(readability/fn_size)<br></code></pre></td></tr></table></figure>
<p>看到了这两个部分都发生了较大的变化。那个超大的case都不见了。不过也只是处理的方式发生变化。我们跟着调整下就行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs bash">template&lt;bool do_access_check, bool transaction_active&gt;<br>ATTRIBUTE_NO_SANITIZE_ADDRESS void ExecuteSwitchImplCpp(SwitchImplContext* ctx) &#123;<br>  ...<br>  //add<br>  int32_t regvalue=ctx-&gt;result_register.GetI();<br>  //这里很重要。需要把我们用来作为主动调用的值给改了。不然调用另外一个函数也会当成fart的主动调用的。<br>  ctx-&gt;result_register=JValue();<br>  int inst_count = -1;            //当前第几个指令<br>  bool flag=<span class="hljs-literal">false</span>;                    //第一个指令是否为goto<br>  //add end<br>  bool const interpret_one_instruction = ctx-&gt;interpret_one_instruction;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    ...<br>    //add<br>    inst_count++;<br>    uint8_t opcode = inst-&gt;Opcode(inst_data)<br>    //如果是主动调用<br>    <span class="hljs-keyword">if</span>(regvalue==111111)&#123;<br>          //第一个指令是goto的处理<br>        <span class="hljs-keyword">if</span>(inst_count == 0 )&#123;<br>            <span class="hljs-keyword">if</span>(opcode == Instruction::GOTO || opcode == Instruction::GOTO_16 || opcode == Instruction::GOTO_32)&#123;<br>                LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;fartext ExecuteSwitchImplCpp Switch inst_count=0 opcode==GOTO &quot;</span>&lt;&lt;<span class="hljs-string">shadow_frame.GetMethod()-&gt;PrettyMethod().c_str();</span><br><span class="hljs-string">                flag=true;</span><br><span class="hljs-string">            &#125;else&#123;</span><br><span class="hljs-string">                LOG(ERROR) &lt;&lt; &quot;fartext ExecuteSwitchImplCpp Switch inst_count=0 opcode!=GOTO &quot;&lt;&lt;shadow_frame</span>.GetMethod()-&gt;PrettyMethod().c_str();<br>                dumpArtMethod(shadow_frame.GetMethod());<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br>        &#125;<br>          //第二个指令是const的处理<br>        <span class="hljs-keyword">if</span>(inst_count == 1)&#123;<br>            <span class="hljs-keyword">if</span>(opcode &gt;= Instruction::CONST_4 &amp;&amp; opcode &lt;= Instruction::CONST_WIDE_HIGH16)&#123;<br>                LOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;fartext ExecuteSwitchImplCpp Switch inst_count=1 opcode==CONST &quot;</span>&lt;&lt;<span class="hljs-string">shadow_frame.GetMethod()-&gt;PrettyMethod().c_str();</span><br><span class="hljs-string">                flag=true;</span><br><span class="hljs-string">            &#125;else&#123;</span><br><span class="hljs-string">                LOG(ERROR) &lt;&lt; &quot;fartext ExecuteSwitchImplCpp Switch inst_count=1 opcode!=CONST &quot;&lt;&lt;shadow_frame</span>.GetMethod()-&gt;PrettyMethod().c_str();<br>                dumpArtMethod(shadow_frame.GetMethod());<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    //add end<br>    switch (opcode) &#123;<br><span class="hljs-comment">#define OPCODE_CASE(OPCODE, OPCODE_NAME, pname, f, i, a, e, v)                                    \</span><br>      <span class="hljs-keyword">case</span> OPCODE: &#123;                                                                              \<br>        bool exit_loop = <span class="hljs-literal">false</span>;                                                                   \<br>        InstructionHandler&lt;do_access_check, transaction_active&gt; handler(                          \<br>            ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, exit_loop);        \<br>        handler.OPCODE_NAME();                                                                    \<br>        /* TODO: Advance <span class="hljs-string">&#x27;inst&#x27;</span> here, instead of explicitly <span class="hljs-keyword">in</span> each handler */                    \<br>        <span class="hljs-keyword">if</span> (UNLIKELY(exit_loop)) &#123;                                                                \<br>          <span class="hljs-built_in">return</span>;                                                                                 \<br>        &#125;                                                                                         \<br>        <span class="hljs-built_in">break</span>;                                                                                    \<br>      &#125;<br>DEX_INSTRUCTION_LIST(OPCODE_CASE)<br><span class="hljs-comment">#undef OPCODE_CASE</span><br>    &#125;<br>    //add<br>      //指令执行结束后，再判断一下是不是主动调用的<br>    <span class="hljs-keyword">if</span>(regvalue==111111)&#123;<br>          //如果这是第3个指令<br>        <span class="hljs-keyword">if</span>(inst_count==2&amp;&amp;flag)&#123;<br>              //如果是下面两种操作码，就可以脱壳并结束了。<br>            <span class="hljs-keyword">if</span>(opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE)&#123;<br>                dumpArtMethod(shadow_frame.GetMethod());<br>                  ArtMethod::disableFartextInvoke();<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br>        &#125;<br>          //如果主动调用的情况还能执行到第4个指令。那就直接脱壳并结束掉。<br>          <span class="hljs-keyword">if</span>(inst_count&gt;2)&#123;<br>            dumpArtMethod(shadow_frame.GetMethod());<br>              ArtMethod::disableFartextInvoke();<br>            <span class="hljs-built_in">break</span>;<br>        &#125;<br>    &#125;<br>    //add end<br>    <span class="hljs-keyword">if</span> (UNLIKELY(interpret_one_instruction)) &#123;<br>      <span class="hljs-built_in">break</span>;<br>    &#125;<br>  &#125;<br>  // Record <span class="hljs-built_in">where</span> we stopped.<br>  shadow_frame.SetDexPC(inst-&gt;GetDexPc(insns));<br>  ctx-&gt;result = ctx-&gt;result_register;<br>  <span class="hljs-built_in">return</span>;<br>&#125;  // NOLINT(readability/fn_size)<br><br></code></pre></td></tr></table></figure>

<h3 id="2-被动调用"><a href="#2-被动调用" class="headerlink" title="2. 被动调用"></a>2. 被动调用</h3><p>app正常运行过程中所发生的函数调用<br>只对dex中部分的类完成加载，只对dex中的部分函数完成调用<br>调用函数不全，导致能够恢复的函数有限</p>
<h3 id="3-主动调用"><a href="#3-主动调用" class="headerlink" title="3. 主动调用"></a>3. 主动调用</h3><p>构造虚拟调用，对app中所有函数完成调用<br>在这些函数执行时，保存函数体CodeItem数据<br>保存数据的时机越晚，效果越好</p>
<h3 id="4-常见的抽取加固脱壳系统"><a href="#4-常见的抽取加固脱壳系统" class="headerlink" title="4. 常见的抽取加固脱壳系统"></a>4. 常见的抽取加固脱壳系统</h3><p>DexHunter、Fupk3、FART、youpk . fartExt</p>
<h2 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h2><h3 id="双亲委派机制的工作原理是-："><a href="#双亲委派机制的工作原理是-：" class="headerlink" title="双亲委派机制的工作原理是 ："></a>双亲委派机制的工作原理是 ：</h3><p> 一个类加开始加载他会把这个请求委托给父类的加载器去执行 如果父类加载器还存在其他父类加载器就会进一步向上委托如果父类可以完成加载 就返回成功若是无法加载则会委托给子类子类再去加载 加载之后的类不会被重复加载 也就是说系统类加载只会交给最上层的类加载器会相对安全。</p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>分为隐式加载和显式加载 </p>
<h4 id="隐式-："><a href="#隐式-：" class="headerlink" title="隐式 ："></a>隐式 ：</h4><p> 创建类的实例 new  访问类的静态遍历 或者未静态变量赋值<br>调用类的静态方法<br>使用反射来强制创建某个类的接口对应的Java.lang.class对象<br>初始化某个类的子类 </p>
<h4 id="显示-："><a href="#显示-：" class="headerlink" title="显示 ："></a>显示 ：</h4><p>使用loadclass（）<br>使用Class.forname（）</p>
<h4 id="类加载的过程-："><a href="#类加载的过程-：" class="headerlink" title="类加载的过程 ："></a>类加载的过程 ：</h4><p>装载 ： 查找和导入class文件<br>链接 ： 其中解析不走是可以选择的<br>    检查 ： 检查载入的class文件数据的正确性<br>    准备 ： 给类的静态变量分内存空间<br>    解析 ： 江符号引用转成直接引用<br>初始化 ： 调用<clinit>函数 对静态变量静态代码块执行初始化工作</clinit></p>
<h3 id="Android系统中的ClassLoader"><a href="#Android系统中的ClassLoader" class="headerlink" title="Android系统中的ClassLoader:"></a>Android系统中的ClassLoader:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">ClassLoader为抽象类;<br>BootClassLoader预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的;<br>BaseDexClassLoader是PathClassLoader、DexClassLoader、 InMemoryDexClassLoader的父类， 类加载的主要逻辑都是在BaseDexClassLoader完成的。<br>SecureClassLoader继承了抽象类ClassLoader,拓展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。<br>其中重点关注的是PathClassLoader和DexClassLoader.<br>PathClassLoader是Androi d默认使用的类加载器，- 个apk中 的Activity等类便是在其中加载。<br>DexClassLoader可以加载任意目录下的dex/ jar/apk/zip文件，比PathClassLoader更灵活， 是实现插件化、热修复以及dex加壳的重点。<br>Android8. 0新引入InMemoryDexClassLoader,从名字便可看出是用于直接从内存中加载dex。<br><br>basedexclassloader 可以拿到 子类的所有类 <br>拿到的是通过对dex解析拿到的所有类<br><br>双亲委派 <br>                             classloader <br>bootclassloader     basedexclassloader  secureclassloader<br>				                     urlclassloader<br><br>inmemorydexclassloader  pathclassloader dexclassloader  <br><br>安卓四大组件一般是在pathclassloader中进行加载注册的 <br>如果在dexclassloader中去加载dex去进行调用startactivity会出现找不到类的情况如何在dexclassloader中加载的组件类有正常的生命周期<br><br>app运行中classloader的参与流程<br><br>bootclassloader加载系统核心库<br>pathclasslocader加载app自身dex<br>进入app自身组件开始执行<br>调用声明application的attachbasecontext<br>调用声明的application的oncreate<br><br><br>有多种解决发方案解决方案 <br>替换系统组件类加载器为我们的dexclassloadeer 设置dexclassloader的parent为系统组件类加载器<br><br>打破原有的双亲关系 在系统组件类加载器和bootclassloader的中间插入我们自己的dexclassloader即可<br><br>将自己的classloader和系统的elements数组进行合并把自己的类加载写入到pathclassloader<br></code></pre></td></tr></table></figure>
<h4 id="dex加固"><a href="#dex加固" class="headerlink" title="dex加固"></a>dex加固</h4><p>1.dex整体加固 文件加载和内存加载<br>2.函数抽取： 在函数粒度完成代码的保护<br>3.vmp 和 dex2c ： java函数nativie化  或者vmp和函数抽取相结合</p>
<h4 id="so加固的种类"><a href="#so加固的种类" class="headerlink" title="so加固的种类"></a>so加固的种类</h4><p>1.基于init，init——array以及jni_onload函数的加壳<br>2.基于自定义linker的加壳</p>
<h4 id="vmp虚拟化保护-虚拟机保护"><a href="#vmp虚拟化保护-虚拟机保护" class="headerlink" title="vmp虚拟化保护(虚拟机保护)"></a>vmp虚拟化保护(虚拟机保护)</h4><p>加固厂商完全可以参考aosp源码里解释器的源码进行修改学习 修改smali指令的操作码 或者还是使用原来的codeitem在自己实现的解释器里执行<br>对每一条指令进行映射</p>
<p>一般是所有被vmp保护的函数都使用一个解释器对于相同类型的函数变成相同类型的jni函数映射到相同的地址 他们有相同的修饰符相同的返回值 直接全部映射到相同的地址 对于不同的函数使用不同的 codeitem 开源的例子（ADVMP）<br>被vmp保护的oncreate函数共享一个解释器绑定在了一个相同的地址</p>
<p>dex2c将smali指令进行等价的jni代码进行转换 转换成jni代码在使用ollvm进行混淆 效果也满强的<br>获取到保护的dex后和vmp一样被保护的函数的属性由java转变为nativie如开源的dcc（dex-to-c cmopiler）</p>
<h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p>那到dex_file 就可以拿到dex_bigen 和 dex_base 就可以完成dex的写出 也就是脱壳 </p>
<p>从加壳的角度来讲ClassLinker::LoadMethod函数执行之后进行hook就可以得到初始化完成以后art对象codeitem的一个偏移在结合dex_file的起始地址就可以得到现在正在初始化的函数的指令部分 这个时候进行一些修改就可以解决函数抽取壳</p>
<h3 id="dex2oat编译流程-：-函数粒度进行编译"><a href="#dex2oat编译流程-：-函数粒度进行编译" class="headerlink" title="dex2oat编译流程 ： 函数粒度进行编译"></a>dex2oat编译流程 ： 函数粒度进行编译</h3><p>并不是所有的函数都会被编译 比如类初始化函数<clinit> 因此对于当一个类被初始化时 该类的初始化函数始终运行在interpreter模式 </clinit></p>
<h4 id="art下函数执行模式"><a href="#art下函数执行模式" class="headerlink" title="art下函数执行模式"></a>art下函数执行模式</h4><p>interpreter 由 art下的解释器解释执行<br>quick模式 直接运行dex2oat编译生成的arm指令</p>
<p>interpreter模式流程<br>从artmethod类中的enterinterpreterforminvoke开始分析 execute-&gt;executemterplmpl或者executeswitchimpl可以看到对于任何一个运行在interpreter模式的java函数来说<br>最终都会进入到art下的解释器中进行解释执行</p>
<h3 id="fart实现的三个功能"><a href="#fart实现的三个功能" class="headerlink" title="fart实现的三个功能"></a>fart实现的三个功能</h3><h4 id="一，构造主动调用链让每一个函数都主动调用-但是不影响app的正常运行"><a href="#一，构造主动调用链让每一个函数都主动调用-但是不影响app的正常运行" class="headerlink" title="一，构造主动调用链让每一个函数都主动调用 但是不影响app的正常运行"></a>一，构造主动调用链让每一个函数都主动调用 但是不影响app的正常运行</h4><p>jni调用java函数标准流程<br>1.得到jclass                           findclass的原理是通过class_linker的findclass获取目标类<br>2.获取jmethodid<br>3.通过call函数调用                      jni中call系列函数最终都会进入到art_method中的invoke<br>解决方案把jmethod转成artmethod 通过自行构建的参数传入art_method中的invoke函数进行主动调用在对传入的参数进行判断 是自行传入的保存下来codeitem的起始地址 然后结束函数 </p>
<h4 id="二，-根据artmethod对象定位内存中codeitem的起始地址"><a href="#二，-根据artmethod对象定位内存中codeitem的起始地址" class="headerlink" title="二， 根据artmethod对象定位内存中codeitem的起始地址"></a>二， 根据artmethod对象定位内存中codeitem的起始地址</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs bash">const DexFile::CodeItem * code_item =<br>			    artmethod-&gt;GetCodeItem();<br>			<span class="hljs-keyword">if</span> (LIKELY(code_item != nullptr)) &#123;<br>				int code_item_len = 0;<br>				uint8_t *item = (uint8_t *) code_item;<br>                //有try <br>				<span class="hljs-keyword">if</span> (code_item-&gt;tries_size_ &gt; 0) &#123;<br>					const uint8_t *handler_data =<br>					    (const uint8_t *) (DexFile::<br>							       GetTryItems<br>							       (*code_item,<br>								code_item-&gt;<br>								tries_size_));<br>					uint8_t *<span class="hljs-built_in">tail</span> =<br>					    codeitem_end(&amp;handler_data);<br>					code_item_len =<br>					    (int) (<span class="hljs-built_in">tail</span> - item);<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>                    //没try<br>					code_item_len =<br>					    16 +<br>					    code_item-&gt;<br>					    insns_size_in_code_units_ * 2;<br>				&#125;<br>				memset(dexfilepath, 0, 2000);<br>				int size_int = (int) dex_file-&gt;Size();	// Length of data<br>				uint32_t method_idx =<br>				    artmethod-&gt;get_method_idx();<br>				sprintf(dexfilepath,<br>					<span class="hljs-string">&quot;/sdcard/fart/%s/%d_%ld.bin&quot;</span>,<br>					szProcName, size_int, gettidv1());<br>				int fp2 =<br>				    open(dexfilepath,<br>					 O_CREAT | O_APPEND | O_RDWR,<br>					 0666);<br>				<span class="hljs-keyword">if</span> (fp2 &gt; 0) &#123;<br>					lseek(fp2, 0, SEEK_END);<br>					memset(dexfilepath, 0, 2000);<br>					int offset = (int) (item - begin_);<br>					sprintf(dexfilepath,<br>						<span class="hljs-string">&quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;</span>,<br>						methodname, method_idx,<br>						offset, code_item_len);<br>					int contentlength = 0;<br>					<span class="hljs-keyword">while</span> (dexfilepath[contentlength]<br>					       != 0)<br>						contentlength++;<br>					write(fp2, (void *) dexfilepath,<br>					      contentlength);<br>					long outlen = 0;<br>					char *base64result =<br>					    base64_encode((char *) item,<br>							  (long)<br>							  code_item_len,<br>							  &amp;outlen);<br>					write(fp2, base64result, outlen);<br>					write(fp2, <span class="hljs-string">&quot;&#125;;&quot;</span>, 2);<br>					fsync(fp2);<br>					close(fp2);<br>					<span class="hljs-keyword">if</span> (base64result != nullptr) &#123;<br>						free(base64result);<br>						base64result = nullptr;<br>					&#125;<br>				&#125;<br><br>			&#125;<br><br><br>		&#125;<br></code></pre></td></tr></table></figure>

<h4 id="三，遍历dex中的所有函数并完成主动调用"><a href="#三，遍历dex中的所有函数并完成主动调用" class="headerlink" title="三，遍历dex中的所有函数并完成主动调用"></a>三，遍历dex中的所有函数并完成主动调用</h4><p>1，手动解析dex文件<br>2.调用getclassnamelist获取所有类名(需要获取classloader当中的mcookie对象)</p>
<h2 id="打造自己的脱壳系统-1"><a href="#打造自己的脱壳系统-1" class="headerlink" title="打造自己的脱壳系统"></a>打造自己的脱壳系统</h2><h4 id="1-将FART迁移到安卓10"><a href="#1-将FART迁移到安卓10" class="headerlink" title="1. 将FART迁移到安卓10"></a>1. 将FART迁移到安卓10</h4><h4 id="2-dex重构"><a href="#2-dex重构" class="headerlink" title="2. dex重构"></a>2. dex重构</h4><h4 id="3-FART存在的问题"><a href="#3-FART存在的问题" class="headerlink" title="3. FART存在的问题"></a>3. FART存在的问题</h4><p>3.1 调用链深度不够，有些壳将原有函数体替换为解密代码，运行时才解密执行<br>3.2 有些壳设置一些垃圾类，当该类被初始化时自动退出<br>3.3 有些壳设置一些垃圾类，实时检测这些类是否加载<br>3.4 动态加载的dex文件，如果没有修正ClassLoader，不会出现在双亲委派关系中，也不会被FART遍历到<br>3.5 需要手动修复codeitem</p>
<h4 id="4-FART改进方案"><a href="#4-FART改进方案" class="headerlink" title="4. FART改进方案"></a>4. FART改进方案</h4><p>4.1 学习youpk的调用链深度<br>4.2 不进行类的初始化，或者不主动调用该类<br>4.3 设置配置文件，类似白名单，对指定类进行主动调用，或者避开指定类的调用<br>    利用Frida主动调用FART的函数，对指定类进行脱壳<br>4.4 利用Frida枚举所有ClassLoader，再主动调用FART的函数进行脱壳<br>Exexute脱壳点对于动态加载的dex也可以脱，除非这个dex没有类的初始化函数<br>4.5每个dex文件保存时，将这个dex的地址以及长度给保存下来。最后在所有主动调用完成时，重新将所有dex文件再保存一次</p>
<h1 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h1><h2 id="1-追踪Java函数调用关系"><a href="#1-追踪Java函数调用关系" class="headerlink" title="1. 追踪Java函数调用关系"></a>1. 追踪Java函数调用关系</h2><p>所在文件：art&#x2F;runtime&#x2F;common_dex_operations.h  PerformCall函数 的起始位置插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// add<br>// <span class="hljs-built_in">caller</span> -&gt; callee<br>ArtMethod* callee = callee_frame-&gt;GetMethod();<br>std::ostringstream oss;<br>oss &lt;&lt; <span class="hljs-string">&quot;[PerformCall] &quot;</span> &lt;&lt; <span class="hljs-string">caller_method-&gt;PrettyMethod() &lt;&lt; &quot; --&gt; &quot; &lt;&lt; callee-&gt;PrettyMethod();</span><br><span class="hljs-string">if(strstr(oss.str().c_str(),&quot;PerformCallBefore&quot;))&#123;</span><br><span class="hljs-string">    LOG(ERROR) &lt;&lt; oss.str();</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// add</span><br></code></pre></td></tr></table></figure>
<h2 id="2-追踪jni函数调用关系"><a href="#2-追踪jni函数调用关系" class="headerlink" title="2. 追踪jni函数调用关系"></a>2. 追踪jni函数调用关系</h2><p>所在文件：art&#x2F;runtime&#x2F;reflection.cc  InvokeWithArgArray函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">// add<br>//在函数的倒数第二行插入<br>ArtMethod* artMethod = nullptr;<br>Thread* self = Thread::Current();<br>const ManagedStack* managedStack = self-&gt;GetManagedStack();<br><span class="hljs-keyword">if</span>(managedStack != nullptr) &#123;<br>    ArtMethod** tmpArtMethod = managedStack-&gt;GetTopQuickFrame();<br>    <span class="hljs-keyword">if</span>(tmpArtMethod != nullptr) &#123;<br>        artMethod = *tmpArtMethod;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(artMethod != nullptr) &#123;<br>    std::ostringstream oss;<br>    oss &lt;&lt; <span class="hljs-string">&quot;[InvokeWithArgArray before] &quot;</span> &lt;&lt; <span class="hljs-string">artMethod-&gt;PrettyMethod() &lt;&lt; &quot; --&gt; &quot;&lt;&lt; method-&gt;PrettyMethod();</span><br><span class="hljs-string">    if(strstr(oss.str().c_str(),&quot;InvokeWithArgArrayBefore&quot;))&#123;</span><br><span class="hljs-string">        LOG(ERROR) &lt;&lt; oss.str();</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// add</span><br></code></pre></td></tr></table></figure>
<h2 id="3-强制运行在解释模式下"><a href="#3-强制运行在解释模式下" class="headerlink" title="3. 强制运行在解释模式下"></a>3. 强制运行在解释模式下</h2><p>3.1 所在文件：art&#x2F;runtime&#x2F;interpreter&#x2F;interpreter.cc  增加函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">// add<br>extern <span class="hljs-string">&quot;C&quot;</span> void <span class="hljs-function"><span class="hljs-title">forceInterpret</span></span>()&#123;<br>    Runtime* runtime = Runtime::Current();<br>    runtime-&gt;GetInstrumentation()-&gt;ForceInterpretOnly();<br>    LOG(WARNING) &lt;&lt; <span class="hljs-string">&quot;forceInterpret is called&quot;</span>;<br>&#125;<br>// add<br></code></pre></td></tr></table></figure>
<p>3.2 将解释器改为switch</p>
<h2 id="4-追踪每一条smali指令"><a href="#4-追踪每一条smali指令" class="headerlink" title="4. 追踪每一条smali指令"></a>4. 追踪每一条smali指令</h2><p>所在文件：art&#x2F;runtime&#x2F;interpreter&#x2F;interpreter_switch_impl-inl.h  增加代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">// add<br>//插入在 ctx-&gt; interpret_one_instaruection;<br>bool shouldTrace = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(strstr(shadow_frame.GetMethod()-&gt;PrettyMethod().c_str(), <span class="hljs-string">&quot;ExecuteSwitchImplCppBefore&quot;</span>)) &#123;<br>    shouldTrace = <span class="hljs-literal">true</span>;<br>&#125;<br>// add<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">// add  插入在shadow_frame.setdexpc（dex_pc）<br>// TraceExecution(shadow_frame, inst, dex_pc);<br><br><span class="hljs-keyword">if</span> (shouldTrace) &#123;<br>    myTraceExecution(shadow_frame, inst, dex_pc);<br>&#125;<br>// add<br></code></pre></td></tr></table></figure>
<p>所在文件：art&#x2F;runtime&#x2F;interpreter&#x2F;interpreter_common.h  增加函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">// add  <br>static inline void myTraceExecution(const ShadowFrame&amp; shadow_frame, const Instruction* inst,<br>                                    const uint32_t dex_pc) REQUIRES_SHARED(Locks::mutator_lock_) &#123;<br><br>    std::ostringstream oss;<br>    oss &lt;&lt; <span class="hljs-string">&quot;[FuncName] &quot;</span> &lt;&lt; <span class="hljs-string">shadow_frame.GetMethod()-&gt;PrettyMethod() &lt;&lt; &quot;\t&quot;</span><br><span class="hljs-string">        &lt;&lt; android::base::StringPrintf(&quot;[Address] 0x%x: &quot;, dex_pc)</span><br><span class="hljs-string">        &lt;&lt; inst-&gt;DumpString(shadow_frame</span>.GetMethod()-&gt;GetDexFile()) &lt;&lt; <span class="hljs-string">&quot;\t[Regs]&quot;</span>;<br>    <span class="hljs-keyword">for</span> (uint32_t i = 0; i &lt; shadow_frame.NumberOfVRegs(); ++i) &#123;<br>        uint32_t raw_value = shadow_frame.GetVReg(i);<br>        ObjPtr&lt;mirror::Object&gt; ref_value = shadow_frame.GetVRegReference(i);<br>        oss &lt;&lt; <span class="hljs-string">android::base::StringPrintf(&quot; vreg%u=0x%08X&quot;, i, raw_value);</span><br><span class="hljs-string">        if (ref_value != nullptr) &#123;</span><br><span class="hljs-string">            if (ref_value-&gt;GetClass()-&gt;IsStringClass() &amp;&amp;</span><br><span class="hljs-string">                !ref_value-&gt;AsString()-&gt;IsValueNull()) &#123;</span><br><span class="hljs-string">                oss &lt;&lt; &quot;/java.lang.String \&quot;&quot; &lt;&lt; ref_value-&gt;AsString()-&gt;ToModifiedUtf8() &lt;&lt; &quot;\&quot;&quot;;</span><br><span class="hljs-string">            &#125; else &#123;</span><br><span class="hljs-string">                oss &lt;&lt; &quot;/&quot; &lt;&lt; ref_value-&gt;PrettyTypeOf();</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    if(strstr(oss.str().c_str(), &quot;myTraceExecutionBefore&quot;)) &#123;</span><br><span class="hljs-string">        LOG(ERROR) &lt;&lt; oss.str().c_str();</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// add</span><br></code></pre></td></tr></table></figure>

<h1 id="过root检测"><a href="#过root检测" class="headerlink" title="过root检测"></a>过root检测</h1><p>平时应⽤测试过程中经常遇⻅Root检测，特别是⾦融类应⽤在启动时进⾏Root环境监<br>测，会向⽤户弹窗提示运⾏环境存在安全⻛险不让APP继续运⾏下⼀步操作或禁⽌安装<br>运⾏（直接闪退）。虽然之前说到magisk配合Shamiko模块可以过掉⼤部分应⽤root检<br>测，⽐较依赖magisk环境，若app对magisk进⾏检测，此时我们⼜要对magiak进⾏隐<br>藏。<br>这⾥的思路是-通过⾃定义su,并去除userdebug编译模式的⼀些特征！</p>
<h2 id="root-常规检测⼿段⼤致可以分为三类"><a href="#root-常规检测⼿段⼤致可以分为三类" class="headerlink" title="root 常规检测⼿段⼤致可以分为三类"></a>root 常规检测⼿段⼤致可以分为三类</h2><ol>
<li><p>⽬ 录 特 征 遍 历 我 们 来 看 段 检 测 代 码 ， 从 代 码 中 可 以 看 会 去 遍 历 “&#x2F;sbin&#x2F;su”, “&#x2F;system&#x2F;bin&#x2F;su”,</p>
</li>
<li><p>“&#x2F;system&#x2F;sbin&#x2F;su”, “&#x2F;system&#x2F;xbin&#x2F;su” 等⽬录其次检测magsik、SuperSU等特征。</p>
</li>
</ol>
<p>2.尝试执⾏root后的⼀些操作 对特定⽬录尝试新建⽂件例如 &#x2F;data、&#x2F;system、&#x2F;etc 等（只有root后才有权限<br>操作的⽬录），或者去执⾏典型的，例如su，还有find、mount等命令。</p>
<p>3.读取⼿机编译版本、调试状态 例如读取&#x2F;system&#x2F;build.prop中 是test-keys（测试版），还是release-keys<br>（发布版)，去获取ro.debuggable、ro.secure的值检测是否有调试状态</p>
<p>其实我们只要通过定制ROM⾃定义su，就可以轻松应对1.⽬录特征遍历和 2.尝试执⾏root后的⼀些操作， 当<br>我 们 把 su 改 成 mysu, 对 应 ⽬ 录 也 ⾃ 定 义 成 mysu ， 提 权 命 令 也 会 变 成 mysu ， 当应⽤执⾏</p>
<p>对&#x2F;data、&#x2F;system、&#x2F;etc 等⽬录进⾏⽂件操作，没有提权命令mysu⾃然也⽆法完成这些操作，最后我们把<br>test-keys 以及ro.debuggable等特征都改成正常值，这样基本上可以做到ROOT检测通杀了。</p>
<h2 id="⾃定义su"><a href="#⾃定义su" class="headerlink" title="⾃定义su"></a>⾃定义su</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">/system/extras/su/Android.mk中su修改为mysu<br>/system/core/libcutils/fs_config.cpp中/system/xbin/su修改为/system/xbin/mysu<br>/system/sepolicy/private/file_contexts中/system/xbin/su修改为/system/xbin/mysu<br></code></pre></td></tr></table></figure>
<h2 id="更改test-keys"><a href="#更改test-keys" class="headerlink" title="更改test-keys"></a>更改test-keys</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ro.build.tags=test-keys被写⼊在system/build.prop⽂件，我们查看这个⽂件看到<br>autogenerated by buildinfo.sh 是被buildinfo.sh⽂件写⼊的，我们找下这个⽂件<br>在/build/make/tools/buildinfo.sh ro.build.tags的值是读取BUILD_VERSION_TAGS ⽽<br>BUILD_VERSION_TAGS 则是/build/core/Makefile 中BUILD_KEYS 给的值，所以我们将 test-keys 改为<br>release-keys即可<br><br></code></pre></td></tr></table></figure>

<h2 id="更改userdebug"><a href="#更改userdebug" class="headerlink" title="更改userdebug"></a>更改userdebug</h2><p>虽然我们改了test-keys 但是ro.build.type、ro.build.display.id、ro.build.flavor、 ro.build.description、<br>ro.build.fingerprint标签中均有userdebug,发布版值应为user 我们先 看下ro.build.type对应的值是来⾃<br>TARGET_BUILD_TYPE</p>
<p>TARGET_BUILD_TYPE 的值⼜是TARGET_BUILD_VARIANT，⼜索引到其他⽂件去了，为了减少出错率，我<br>们就在这⾥直接赋值user</p>
<p>ro.build.flavor 对应TARGET_BUILD_FLAVOR</p>
<p>TARGET_BUILD_FLAVOR :&#x3D; $(TARGET_PRODUCT)-$(TARGET_BUILD_VARIANT) 我们对⽐下值就可以判断出<br>TARGET_BUILD_VARIANT 就是userdebug字符串</p>
<p>我们直接改成<br>TARGET_BUILD_FLAVOR :&#x3D; $(TARGET_PRODUCT)-user</p>
<p>其他⼏个地⽅就可以按照此⽅式挨个去除即可，只在&#x2F;build&#x2F;core&#x2F;Makefile 中改动即可</p>
<h2 id="修改ro-debuggable"><a href="#修改ro-debuggable" class="headerlink" title="修改ro.debuggable"></a>修改ro.debuggable</h2><p>在&#x2F;build&#x2F;core&#x2F;main.mk可以直接把ro.debuggable指定为0 这样我们就关闭了全局debug模式了，但是平时<br>分析应⽤需要调试所以我就保留了这个功能，借助mprop帮助我们隐藏ro.debuggable的值，这样既能保留全<br>局debug模式，⼜隐藏了ro.debuggable的值，缺点就是每次⼿机重启，需要执⾏⼀下命令，才能做到隐藏。</p>
<h1 id="暂时完结"><a href="#暂时完结" class="headerlink" title="暂时完结"></a>暂时完结</h1><p>定制系统其实相对来说是一种最简单最快的方式去实现想要实现的功能，使用别的方式虽然更便捷但是相对而言需要花费更多时间。比如使用frida去实现trace smali指令 就需要各种hook 极其复杂<br>优点：花最少的时间做最多的事情<br>缺点：不通用 不能很好的适配各种设备 绕过风控更加复杂 </p>
<p>最优其实是根据国内厂商的手机去修改so文件来实现编译系统源码实现的功能 不仅速度快而且也不需要额外处理特殊风控</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>记录编译aosp+修改源码</div>
      <div>http://example.com/2022/02/15/编译aosp-修改源码定制各种功能/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>听说你是小兔叽</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年2月15日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年11月17日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="记录一次编译内核，修改内核源码监控系统调用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">记录一次编译内核，修改内核源码监控系统调用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
